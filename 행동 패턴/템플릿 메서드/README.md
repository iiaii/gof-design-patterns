# #GoF디자인패턴/행동패턴/템플릿메서드
템플릿 메서드 패턴은 전체적인 알고리즘은 상위 클래스에서 구현하면서 다른 부분은 하위 클래스에서 구현할 수 있도록 하는 디자인 패턴. (전체적인 알고리즘 코드를 재상용하는데 유용) -> 추상클래스 (일치하는 부분은 구현(템플릿 메서드), 하위클래스로 오버라이드가 필요한 부분은 protected abstract 메서드로 넘김(primitive 혹은 hook 메서드))
[자바 객체지향 디자인 패턴 - 책]


## 템플릿 메서드 (Template Method)

### 의도

객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미룬다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계 처리를 서브클래스에서 재정의할 수 있게 한다.


### 동기

Application 클래스와 Document 클래스를 제공하는 응용프로그램 프레임워크를 생각해 보면, Application 클래스는 파일이나 특정한 외부 형식으로 저장된 문서를 열 수 있고, Document 객체는 파일에서 읽은 문서에 정보를 나타낸다.

특정한 요구나 때에 따라서 프레임워크가 정의한 Application 클래스와 Document 클래스를 상속한 서브클래스를 정의하여 새로운 응용프로그램을 구축할 수 있다. 예를 들어 그림 그리기 응용프로그램은 DrawApplication 클래스와 DrawDocument 클래스를 정의할 수 있고, 스프레드시트 응용프로그램은 SpreadsheetApplication, SpreadsheetDocument 클래스를 정의할 수 있다.


[image:ABB1A3E5-ACD7-404F-896B-1675F67B0BDF-85545-000247DAEF258B7E/템플릿메서드1.jpeg]

추상 클래스인 Application 클래스의 OpenDocument() 연산에는 문서를 열고 읽는 기본 알고리즘이 정의되어 있다. OpenDocument()는 문서를 여는 필수적인 절차를 정의한다. 즉, 열 수 있는 문서인지 확인하여, 응용프로그램마다 필요한 Document 객체를 생성하고, 이를 Document 객체 집합에 추가한 후, 파일에서 문서를 읽어 Document 객체에 싣는다.

이 같은 필수 처리 절차를 정의한 OpenDocument()를 가리켜 템플릿 메서드라고 한다. 템플릿 메서드는 서브클래스가 오버라이드할 수 있는 추상 연산을 사용하여 알고리즘을 정의한다. 즉, OpenDocument() 연산에서 호출하는 각 연산들에 대한 실제 구현은 Application 클래스를 상속하는 서브클래스가 제공한다. 템플릿 메서드에서는 열 수 있는 문서인지를 점검하는 일(CanOpenDocument), 그리고 Document 클래스의 인스턴스를 생성하는 일(DoCreateDocument) 등을 정의하며, 실제 이 같은 처리가 구체적으로 어떻게 되는지는 Application 클래스의 서브클래스가 정의한다. Document 클래스는 문서를 판독하는데 필요한 단계만 정의한다. 템플릿 메서드는 Application 서브클래스가 문서를 언제 열어야 하는지를 알 수 있도록 하는일도 정의한다.

추상 연산을 통해서 알고리즘의 일부 단계를 정의함으로써, 템플릿 메서드는 각 단계의 순서는 고정하되 Application 클래스와 Document 클래스의 서브클래스는 필요에 따라 이들 단계의 처리를 다양화시킬 수 있도록 한다.


### 활용성

템플릿 메서드 패턴은 다음의 경우에 사용한다.

- 어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때
- 서브클래스 사이의 공통적인 행동을 추출해 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때. 옵다이크와 존슨이 설명했듯 일반화를 위한 리팩토링의 좋은 예다. 먼저 기존 코드에서 나타나는 차이점을 뽑아 이를 별도의 새로운 연산들로 구분해 놓는다. 그런 뒤 달라진 코드 부분을 이 새로운 연산을 호출하는 템픞릿 메서드로 대체한다.
- 서브클래스의 확장을 제어할 수 있다. 템플릿 메서드가 어떤 특정한 시점에 훅 연산을 호출하도록 정의함으로써, 그 특정 시점에서만 확장되도록 한다.


### 구조

[image:22AAF8EB-0696-421A-9DF4-D5D4683B3359-85545-00024D2FC742A299/템플릿메서드2.jpeg]


### 참여자

- **AbstractClass** (Application) : 서브클래스들이 재정의를 통해 구현해야 하는 알고리즘 처리 단계 내의 기본 연산을 정의한다. 그리고 알고리즘의 뼈대를 정의하는 템플릿 메서드를 구현한다. 템플릿 메서드는 AbstractClass에 정의된 연산 또는 다른 객체 연산뿐만 아니라 기본 연산도 호출한다.
- **ConcreteClass** (MyApplication) : 서브클래스마다 달라진 알고리즘 처리 단계를 수행하기 위한 기본 연산을 구현한다.


### 협력 방법

ConcreteClass는 AbstractClass를 통해 알고리즘의 변하지 않는 처리 단계를 구현한다.


### 결과

템플릿 메서드는 코드 재사용을 위한 기본 기술이다. 특히 클래스 라이브러리 구현 시 중요한 기술인데, 이는 라이브러리에 정의할 클래스들의 공통 부분을 분리하는 수단이기 때문이다.

템플릿 메서드는 할리우드 원칙이라는 역전된 제어 구조를 끌어낸다. (“전화하지 마세요. 우리가 연락할게요.”라는 것) 즉, 부모 클래스는 서브클래스에 정의된 연산을 호출할 수 있지만 반대 방향의 호출은 안된다.

템플릿 메서드는 여러 종류의 연산 중 하나를 호출한다.

- 구체 연산 (concrete operation) : ConcreteClass나 사용자 클래스에 정의된 연산
- AbstractClass 구체 연산 : 서브클래스에서 일반적으로 유용한 연산
- 기본 연산 : 추상화된 연산
- 팩토리 메서드
- 훅 연산 (hook operation) : 필요하다면 서브클래스에서 확장할 수 있는 기본 행동을 제공하는 연산. 기본적으로는 아무 내용도 정의하지 않는다.

템플릿 메서드 패턴에서는 어떤 연산이 훅 연산인지(오버라이드가 가능한지) 추상 연산인지(꼭 오버라이드해야 하는지)를 지정해 두는 것이 대단히 중요하다. 훅 연산은 나중에 재정의할 수도 있고, 재정의하지 않을 수도 있는 메서드이고, 추상 연산은 반드시 재정의해야 하는 연산이다. 추상화할 클래스를 효과적으로 재사용하기 위해서, 서브클래스 작성자는 어떤 연산들이 오버라이드용으로 설계되었는지를 정확하게 이해하고 있어야 한다.

서브클래스는 부모 클래스에 정의된 연산을 명시적으로 호출하고 또 재정의함으로써 부모 클래스 연산의 행동을 확장한다.

간혹 상속 받은 연산을 호출하는 일을 잊어버이는데, 그래서 이 같은 서브클래스가 부모 클래스의 행동을 확장하는 연산들을 템플릿 메서드로 옮겨 놓음으로써 부모 클래스에게 서브클래스의 확장을 제어할 수 있는 권한을 부여할 수 있다. 이 아이디어는 부모 클래스의 템플릿 메서드에서 훅 연산을 호출하도록 하는 것이다. 


### 구현

1. **접근 제한 방법을 이용.** 템플릿 메서드에서 호출하는 기본 연산들을 protected 멤버로 구현하면 이 연산들을 템플릿 메서드만 호출할 수 있게 된다. 오버라이드해야 하는 기본 연산은 반드시 순수 가상 함수로 정의한다. 템플릿 메서드 자체는 재정의되면 안된다. 따라서 템플릿 메서드는 비가상 멤버 함수로 만든다.

2. **기본 연산의 수를 최소화한다.** 템플릿 메서드를 구현하는 중요한 목적 중 하나는 서브클래스가 알고리즘을 실체화하기 위해 오버라이드해야 하는 기본 연산의 개수를 줄이는 것이다. 재정의가 필요한 연산의 수가 많아질수록 사용자에게는 지겨운 일만 늘어난다.

3. **이름을 짓는 규칙을 만든다.** 재정의가 필요한 연산은 식별이 잘 되도록 접두사를 붙이는 것이 좋다. (DoCreateDocument, DoRead 등)


### 관련 패턴

팩토리 메서드 패턴은 종종 템플릿 메서드 패턴이라고도 한다. 동기절의 예제처럼 팩토리 메서드인 DoCreateDocument()는 템플릿 메서드인 OpenDocument() 연산이 호출된다.

템플릿 메서드 패턴은 상속을 이용해 다양한 알고리즘을 만들어 낸다. 이점은 전략 패턴과 관계가 있으며, 각 전략들은 위임을 통해 전체 알고리즘을 다양화한다.

