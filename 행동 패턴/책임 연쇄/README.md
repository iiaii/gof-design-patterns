# #GoF디자인패턴/행동패턴/책임연쇄
[Java언어로배우는디자인패턴 Chain of Responsibility (책임 연쇄) 패턴 : 네이버 블로그](https://m.blog.naver.com/PostView.nhn?blogId=janghun741&logNo=10187839624&proxyReferer=https:%2F%2Fwww.google.com%2F)
[책임 연쇄/사슬 패턴 :: Programming](https://programmingfbf7290.tistory.com/entry/%EC%B1%85%EC%9E%84-%EC%97%B0%EC%87%84%EC%82%AC%EC%8A%AC-%ED%8C%A8%ED%84%B4)

## 책임 연쇄 (Chain Of Responsibility)

### 의도

메시지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴이다. 하나의 요청에 대한 처리가 반드시 한 객체에서만 되지 않고, 여러 객체에게 그 처리 기회를 주려는 것이다.


### 동기

GUI에 잇는 문맥 감지 도움말 기능을 생각해 보면 사용자가 정보를 선택할 경우 그 부분에 대한 도움말 정보를 얻을 수 있다. 도움말의 내용은 선택한 주체가 무엇이며, 현재 그 주체의 상황이 어떠한가에 따라 다를 수 있다. 즉, 대화상자 내에 있는 버튼 위젯은 기본 윈도우에 있는 버튼과 내용이 다른 도움말을 제공해야 한다. 만약 선택한 주체에 대한 구체적인 도움말이 없다면, 일반적인 도움말이라도 제공해야 한다.

따라서 도움말 정보는 구체적인 내용부터 일반적인 내용까지 내용의 일반성에 따라서 구성하는 것이 자연스럽다. 게다가, 도움말에 대한 요청은 여러 사용자 인터페이스 객체 중 어느 하나로 처리된다고 보는게 명확하다 즉, 도움말 요청이 어떤 상황에서 발생했는지에 따라서, 요청을 받은 객체가 직접 그 요청을 처리하지 않을 수도 있다. 어느 정도의 구체적인 도움말이 가능한가에 따라 여러 인터페이스 중 하나가 이 요청을 처리할 수 있다.

허나, 문제는 궁극적으로 도움말을 제공해야 할 객체가 도움말 요청을 보내는 객체 (버튼)에게 알려져 있지 않다는 것이다. 즉, 요청을 일으키는 객체는 실제로 자신에게 해당하는 도움말을 제공하는 객체가 누구인지 알 수 없다. 이를 위해서 도움말 요청을 발생시키는 버튼과 도움말 정보를 제공하는 객체를 분리해야 할 필요가 있다.  (이 부분의 기작을 정의하는 패턴이 책임 연쇄 패턴)

[image:2B410799-38E8-44C7-8A39-5474FDF9D30E-85545-000183A1A0DB44D8/책임연쇄1.jpeg]

이 패턴의 아이디어는 메시지 송신 측과 수신 측을 분리하는 것이다. 이를 위해 이 요청을 처리하는 기회를 다른 객체에 분산한다. 요청은 실제 이 요청을 처리할 객체를 찾을 때 까지 객체 연결 고리를 따라 전달된다. 즉, 송신하는 측이 자신이 아는 주체에게 처리를 요청하면, 이를 수신한 객체가 자신과 연결된 고리를 따라서 계속 이 요청을 전달하고, 이 중에 어느 한 객체가 실제 상황에 적합하다고 판단되면 자신에게 정의된 서비스를 제공한다.

이 객체 연결 고리의 첫 번째 객체가 요청을 받으면 자신이 처리하거나 또는 다음 후보에 전달한다. 객체는 메시지를 발생시킬 때 실제 이 요청을 받아 처리할 객체가 누구인지 모를 수도 있다. 사용자가 PringDialog 클래스에 포함된 Print 버튼에 대한 도움말을 요청했다고 가정하면, PrintDialog의 인스턴스는 자신이 속한 응용프로그램이 무엇인지 안다.

PrintDialog에 있는 OK 버튼은 특별한 도움말을 제공할 것이 없지만, Print 버튼에 대해서 도움말을 볼 수 있다고 가정해보면, 사용자가 어떤 객체의 경우는 해당 객체의 인터페이스를 통해 도움말을 얻을 수 있고, 어떤 객체의 경우는 다른 객체를 통해 도움말을 얻을 수 있다는 사실을 하드코딩하는 것은 바람직하지 않다.

사용자가 버튼에 대한 도움말을 얻기 위해서 Print를 선택했다고 하자. 버튼은 PrintDialog 인스턴스에 포함되어 있고, 자신이 속한 응용프로그램 객체를 알기 때문에 다음과 같은 메시지 전달 관계가 일어날 수 있다.

aPrintButton 객체와 aPrintDialog 객체에서는 도움말 요청이 처리되지 않고 실제로 Application 클래스에 가서야 메시지 전달이 중단되며, anApplication 객체가 도움말에 대한 처리를 담당했다. 사용자는 요청을 발생하기는 했지만, 이 요청을 궁극적으로 처리할 객체의 직접적인 참조자는 없다. 이 예에서 보면, 사용자는 그저 PrintButton에 메시지를 보냈을 뿐이다.

연결 고리를 따라 요청을 계속 전달할 수 있어야 하고, 메시지 수신 객체를 명시할 수 없는 상황을 고려한다면, 객체의 연결 고리에 존재하는 객체는 누구든지 동일한 요청을 처리할 수 있어야 한다. 이를 위해서 연결 고리의 모든 객체들은 공통의 인터페이스를 가져야 한다. 이는 하나의 클래스 계통으로 정의하면 가능한 일이다. 예를 들어, 본 도움말 시스템은 HelpHandler 클래스 HandleHelp() 연산을 정의한다. HelpHandler 클래스는 연결 고리에 존재하는 다른 후보 객체들에 대한 부모 클래스들이다. 도움말 요청을 처리하고자 하는 모든 클래스가 HelpHandler 클래스를 부모 클래스로 정의함으로써 인터페이스가 같아진다. 

Button, Dialog, Application 클래스들은 HelpHandler 클래스에 정의된 연산을 사용하여 도움말에 대한 요청을 처리한다. HelpHandler 클래스에 정의한 HandleHelp() 연산의 기본 구현은 단순히 자신에게 도달한 요청을 연결 고리에 정의된 다음번 객체에게 전달하는 것이다. 이 HelpHandler 클래스를 상속받는 서브클래스들은 자신에게 제공할 도움말이 있으면 제공하도록 이 연산을 재정의한다. 그렇지 않고 자신이 제공할 도움말이 없다면 다른 객체의 연산을 호출하도록 하는 기본 구현을 따르면 된다.


### 활용성

책임 연쇄 패턴은 다음의 경우에 사용한다.

- 하나 이상의 객체가 요청을 처리해야 하고, 그 요청 처리자 중 어떤 것이 선행자인지 모를 때. 처리자가 자동으로 확정되어야 한다.
- 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때
- 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때


### 구조


[image:A369C063-FDFB-4035-B9A3-57C18D6D1560-85545-0001848E698E075D/책임연쇄2.jpeg]


### 참여자

- **Handler** (HelpHandler) : 요청을 처리하는 인터페이스를 정의하고, 후속 처리자와 연결을 구현한다. 즉, 연결 고리에 연결된 다음 객체에게 다시 메시지를 보낸다.
- **ConcreteHandler** (PrintButton, PrintDialog) : 책임져야 할 행동이 있다면 스스로 요청을 처리하여 후속 처리자에 접근할 수 있다. 즉, 자신이 처리할 행동이 있으면 처리하고, 그렇지 않으면 후속 처리자에 다시 처리를 요청한다.
- **Client** : ConcreteHandler 객체에게 필요한 요청을 보낸다.


### 협력 방법

- 사용자는 처리를 요청하고, 이 처리 요청은 실제로 그 요청을 받을 책임이 있는 ConcreteHandler 객체를 만날 때까지 정의된 연결 고리를 따라서 계속 전달된다.


### 결과

1. **객체 간의 행동적 결합도가 적어진다.** 다른 객체가 어떻게 요청을 처리하는지 몰라도 된다. 단지 요청을 보내는 객체는 이 메시지가 적절하게 처리될 것이라는 것만 확신하면 된다. 메시지를 보내는 측이나 받는 측 모두 서로를 모르고, 또 연결된 객체들조차도 그 연결 구조가 어떻게 되는지 모른다.

결과적으로 이 패턴은 객체들 간의 상호작용 과정을 단순화시킨다. 객체가 관련되 모든 후보 객체들을 다 알 필요 없이 자신은 단순하게 자신과 연결된 단 하나의 후보 객체만 알면 되는 것이다.

2. **객체에게 책임을 할당하는 데 유연성을 높일 수 있다.** 객체의 책임을 여러 객체에게 분산시킬 수 있으므로 런타임에 객체 연결고리를 변경하거나 추가하여 책임을 변경하거나 확장할 수 있다.

3. **메시지 수신이 보장되지는 않는다.** 어떤 객체가 이 처리에 대한 수신을 담당한다는 것을 명시하지 않으므로 요청이 처리된다는 보장이 없다. 만약 객체들 간의 연결 고리가 잘 정의되지 않았다면, 요청을 처리되지 못한 채로 버려 질 수 있다.


### 구현 

1. **후속 처리자들의 연결고리 구현하기.** 2가지 방법이 있다. 하나는 새로운 연결을 만드는 것 (Handler 클래스에 정의하지만, ConcreteHandler 클래스에 정의할 수도 있다), 다른 하나는 이미 있는 연결 정보를 사용하는 것이다.

2. **후속 처리자 연결하기.** 연결 정보를 정의하기 위해 미리 정의된 참조자가 없다면 직접 정의해야 한다. 이때 Handler 클래스는 요청 처리에 대한 인터페이스를 정의할 뿐만 아니라 후속 처리자에 대한 정보 저장의 인스턴스 변수도 정의해야 한다. 

3. **처리 요청의 표현부를 정의한다.** HandleHelp() 연산에서처럼 요청 자체를 연산 호출로 하드 코딩하거나 매개변수로 받아들이도록 하는 처맇자 함수를 하나만 정의하는 방법이 있다.


### 관련 패턴

책임 연쇄 패턴은 컴포지트(복합체) 패턴과 함께 대부분 사용되는데, 이때 구성요소의 부모는 후속 처리자처럼 동작한다.

