# #GoF디자인패턴/행동패턴/옵저버
[디자인패턴 옵저버 패턴 ( Observer Pattern ) :: victolee](https://victorydntmd.tistory.com/296?category=719467)
[디자인패턴 - 옵저버 패턴(Observer Pattern)](https://flowarc.tistory.com/entry/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4Observer-Pattern)
[옵저버 패턴(Observer Pattern) - 기계인간 John Grib](https://johngrib.github.io/wiki/observer-pattern/)

## 옵저버 (Observer - 감시자)

### 의도

객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만든다.


### 다른 이름

종속자 (Dependent), 게시 - 구독 (Publish - Subscribe)


### 동기

어떤 하나의 시스템을 서로 연동되는 클래스 집합으로 분할했을 때 발생하는 공통적인 부작용은 관련된 객체 간에 일관성을 유지하도록 해야 한다는 것이다. 그렇다고 이 일관성 관리를 위해서 객체 간의 결합도를 높이고 싶지는 않다. (각 클래스의 재사용성이 떨어지기 때문)

예를 들어, 많은 그래픽 사용자 인터페이스 툴킷은 표현 부분과 이에 대응하는 데이터를 분리한다. 응용프로그램 자료와 표현을 정의하는 클래스는 독립적으로 재사용할 수 있다. 그러나 이들은 함께 동작해야 한다. 예를 들어, 테이블 형태의 객체와 바 형태로 표현된 객체 모두 하나의 동일한 자료 값을 나타내나, 스프레드 시트와 바는 서로 관련 없는 클래스들이므로 독립적으로 재사용이 가능해야 한다. 만약, 이 독립적 객체가 하나의 정보 값을 표현하는 데 함께 사용된다면, 사용자가 스프레드시트에서 정보를 변경할 때 바에도 이 변경된 정보가 반영되어야 한다.

스프레드시트와 바 차트는 데이터 객체에 종속적이기 때문에 그 데이터에 일어난 변경을 통보받아야 한다. 그러나 반드시 이 예처럼 종속적인 객체의 개수가 2개로 제한되는 것은 아니다. 서로 다른 다수의 사용자 인터페이스가 하나의 데이터에 종속될 수 있다. 

[image:44FFA951-C3E7-4C06-9E22-334B7B8E8AF2-85545-0001C7AD8D114116/옵저버1.jpeg]

옵저버(감시자) 패턴은 이런 관련성을 관리하는 패턴이다. 이 패턴에서 중요한 객체는 주체(subject)와 감시자(observer)이다. 주체는 독립된 여러 개의 감시가 있을 수 있다. 모든 감시자는 주체의 상태 변화가 있을 때 마다 이 변화를 통보받는다. 각 감시자는 주체의 상태와 자신의 상태를 동기화시키기 위해 주체의 상태를 알아본다.

이런 종류의 상호작용을 게시 - 구동 (Pub - Sub) 관계라고 한다. 주체는 상태 변경에 대한 통보를 하는 것이므로 누가 감시자인지 모른 채 통보를 발송한다. 불특정 다수의 감시자가 이 통보를 수신하기 위해서 구독을 신청하는 것이다.


### 활용성

다음 상황 중 한 가지에 속하면 옵저버 패턴을 사용한다.

- 어떤 추상 개념이 두 가지 양상을 갖고 하나가 다른 하나에 종속적일 때. 각 양상을 별도의 객체로 캡슐화하여 이들 각각을 재상용할 수 있다.
- 한 객체에 가해진 변경으로 다른 객체를 변경해야 하고, 프로그래머들은 얼마나 많은 객체들이 변경되어야 하는지 몰라도 될 때
- 어떤 객체가 다른 객체에 자신의 변화를 통보할 수 있는데, 그 변화에 관심이 있어 하는 객체들이 누구인지에 대한 가정 없이도 그러한 통보가 될 때


### 구조

[image:EF6F9B58-97DC-4D9F-947C-4E1185489F17-85545-0001C7EDFF51B1B7/옵저버2.jpeg]


### 참여자

- **Subject** : 감시자들을 알고 있는 주체이다. 임의 개수의 감시자 객체는 주체를 감시할 수 있다. 주체는 감시자 객체를 붙이거나 떼는 데 필요한 인터페이스를 제공한다.
- **Observer** : 주체에 생긴 변화에 관심 있는 객체를 갱신하는 데 필요한 인터페이스를 정의한다. 이로써 주체의 변경에 따라 변화되어야 하는 객체들의 일관성을 유지한다.
- **ConcreteSubject** : ConcreteObserver 객체에게 알려주어야 하는 상태를 저장한다. 또한 이 상태가 변경될 때 감시자에게 변경을 통보한다.
- **ConcreteObserver** : ConcreteSubject 객체에 대한 참조자를 관리한다. 주체의 상태와 일관성을 유지해야 하는 상태를 저장한다. 주체의 상태와 감시자의 상태를 일관되게 유지하는 데 사용하는 갱신 인터페이스를 구현한다.


### 협력 방법

- ConcreteSubject는 Observer의 상태와 자신의 상태가 달라지는 변경이 발생할 때마다 감시자에게 통보한다.
- ConcreteSubject에서 변경이 통보된 후 , ConcreteObserver는 필요한 정보를 주체에게 질의하여 얻어온다. ConcreteObserver는 이 정보를 이용해서 주체의 상태와 자신의 상태를 일치시킨다. 다음 다이어그램은 하나의 주체 및 두 감시자 사이의 협력 관계를 표현한 것이다.

[image:719695C1-609A-4B26-AA07-B85AF7A98BF5-85545-0001C84394190937/옵저버3.jpeg]

변경을 유발하는 Observer 객체가 어떻게 주체한테서 변경 통보를 받을 때까지 수정을 늦추는지 보면, Notify() 연산은 주체로만 호출되는 것이 아니고, 감시자나 다른 객체들로 호출이 가능하다. (몇가지 변형 방법이 있음 - 구현)


### 결과

옵저버 패턴을 사용하게 되면 주체 및 감시자 모두를 독립적으로 변형하기 쉽다. 감시자를 재사용하지 않고도 주체를 재사용할 수 있고, 주체 없이도 감시자를 재사용할 수 있다. 또한 주체나 감시자의 수정 없이도 감시자를 추가할 수 있다.

1. **Subject와 Observer 클래스 간에는 추상적인 결합도만이 존재한다.** 주체가 아는 것은 감시자들의 리스트일 뿐이다. 이 감시자들은 Observer 클래스에 정의된 인터페이스를 따른다. 그러나 주체는 어떤 ConcreteObserver 클래스가 있는지에 대해서는 알 필요가 없다. 그러므로 주체와 감시자 간의 결합은 추상적이며, 그 조차도 최소화되어 있다.

Subject와 Observer 클래스가 강결합되지 않기 때문에, 이들은 시스템의 여러 추상화 계층에 속할 수 있다. 하위 수준의 주체라할지라도 상위 수준의 감시자와 연결되어 교류할 수 있다. Subject와 Observer 클래스가 하나로 합쳐져 있었다면, 그 합쳐진 객체는 하위 수준 계층과 상위 수준 계층에 걸쳐 퍼져 있어야 하거나, 두 계층 중 어느 하나에 속하도록 만들 수 밖에 없었을 것이다.

2. **브로드캐스트 방식의 교류를 가능하게 한다.** 일반적인 요청과 달리, 감시자 패턴에서 주체가 보내는 통보는 구체적인 수신자를 지정할 필요가 없다. 이 통보는 주체의 정보를 원하는 모든 객체들이 이 변화 정보를 원하는지 알 필요가 없고, 단지 자신의 감시자에게만 상태 변화 사실을 알려주면 감시자가 이 통보를 처리할지 무시할지를 결정한다.

3. **예측하지 못한 정보를 갱신한다.** 감시자는 다른 감시자의 존재를 모르기 때문에 주체를 변경하는 비용이 궁극적으로 어느 정도인지 모른다. 주체에 계속적으로 어떤 연산이 가해질 때 감시자와 주체에 종속된 다른 객체들의 연속적인 수정을 일으킬 수 있게 된다. 게다가 잘 정의된 것도, 잘 유지된 것도 아닌 종속성 기준 때문에 불필요한 갱신이 일어날 수도 있다. 추적도 까다로울 수 있다.

이 문제는 단순한 갱신 프로토콜로는 주체의 무엇을 변경했는지에 대한 상세한 정보를 알 수 없다는 사실 때문에 더욱 좋지 않다. 감시자가 무엇이 변했는지 알 수 있게 해 주는 별도의 프로토콜이 추가되지 않는 한 변경을 유추하는 작업은 어렵다.


### 구현

1. **주체와 그것의 감시자를 대응시킨다.** 자신이 통보해 주어야 하는 감시자들을 주체가 지속적으로 관리하는 가장 쉬운 방법은 주체에 감시자에 대한 참조자를 저장하는 것이다. 만약 주체가 많고 감시자가 적다면 모든 주체들마다 감시자에 대한 참조자를 다 갖고 있을 테니 저장 공간의 낭비가 심할 것이다. 공간을 절약할 수 있는 한 가지 방법은 별도의 탐색용 자료 구조(해시테이블 등)를 두고 주체와 감시자 간의 대응 관계를 관리하게 하는 것이다. 어떠한 감시자도 갖지 않는 주체라면 저장 공간을 사용하지 않기 때문에 낭비되는 저장공간이 없다. 그러나 이 방법을 쓰면 별도의 객체를 통해서 감시자에 대한 참조자를 얻어야 하는 부담이 생긴다.

2. **하나 이산의 주체를 감시한다.** 어떨 때는 하나 이상의 주체에 종속된 감시자가 있을 수도 있다. 예를 들어, 스프레드시트는 하나 이상의 데이터에 종속될 수 있다. 감시자가 어떤 주체에서 통보가 전달되는지 알아야 한다면 Update() 연산을 확장할 필요가 있다. 주체는 Update() 연산에서 자신을 매개변수화하여 감시자가 어떤 주체를 확인하고 있는지 알 수 없도록 한다.

3. **누가 갱신을 촉발(trigger)시킬 것인가?** 주체와 감시자가 각자 자신의 값을 정확하게 유지하기 위해서는 통보 메커니즘에 의존할 수 밖에 없다. 값을 갱신하려면 어느 객체가 Notify() 메서드를 호출해야 할까? (2가지 선택사항)

> **(1)** Subject 클래스의 상태 변경 후 상태를 지정하는 연산에서 Notify()를 호출한다. 이 방법의 장점은 주체가 정의한 Notify()를 사용자가 호출할 필요가 없다는 점이고 단점은 계속되는 연산의 수행으로 여러번 수정해야 하므로 비효율적이다.

> **(2)** 사용자가 적시에 Notify()를 호출하는 책임을 지도록 해야 한다. 이로써 사용자가 일련의 상태 변경이 될 때까지 갱신의 시작을 미룰 수 있다. 그렇기 때문에 중간 중간 불필요한 수정이 일어나지 않는다. 단점은 사용자에게 수정하게 하는 추가적 행동을 정의해야 한다는 것이다. 이렇게 되면 오류가 많이 생길 수 있다. 왜냐하면 사용자가 Notify()를 호출하는 것을 잊어버릴 때가 많기 때문이다.

4. **삭제한 주체에 대한 무효 참조자를 계속 유지할 때가 있다.** 주체의 삭제로 감시자가 무효 참조자를 갖게 되도록 만들면 안된다. 이 무효 참조자를 피하는 한가지 방법은 주체가 감시자에게 “자신이 삭제되었으니 감시자에 대한 참조자를 없애라”고 통보하는 것이다. 다른 객체들이 감시자를 참조할 수 있고, 또 감시자들이 다른 주체를 관찰해야 하기 때문에, 이런 감시자의 삭제는 있을 수 있는 일이다.

5. **통보 전에 주체의 상태가 자체 일관성을 갖추도록 만들어야 한다.** 감시자는 자신의 상태를 변경하기 위해서 주체에서 현재 상태를 질의해 온다. 이러한 자체 일관성 규칙은 Subject 서브클래스에 정의한 연산이 상속한 연산을 호출하게 되면 뜻하지 않게 깨지기 쉽다. 예를 드렁 다음 정의한 통보 코드에서는 슈퍼클래스 연산을 먼저 호출하고 자신의 상태 변경한 상태는 반영되지 않으므로 문제가 발생한다.

이 문제를 피하려면, Subject 클래스에 템플릿 메서드를 정의하고 이 메서드로 통보를 처리한다. 재정의할 서브클래스에서 오버라이드할 기본 연산을 정의하고 템플릿 메서드의 맨 마지막 연산에서 실제 Notify() 연산을 수행한다. 이렇게 하면 Subject 연산을 서브클래스에서 오버라이드할 때 그 객체는 자기 일관성을 유지할 수 있게 된다.

6. **감시자별 갱신 프로토콜을 피한다 (푸시 모델 & 풀 모델).** 옵저버 패턴을 구현하려고 변경이 발생할 때 주체가 추가적인 정보를 브로드캐스트하게 만들 때가 많다. 주체는 Update() 연산의 인자로 이 추가적인 정보를 전달해야 한다. 이 정보의 양은 많을 수도, 적을 수도 있으며 그 범위가 다양하다.

극단적으로 주체가 자신의 변경에 대한 상세한 정보를 감시자에게 전달하는 푸시모델을 이용할 수 있다. 또 다른 극단적인 예로 주체가 최소한의 정보만을 전달하고 감시자가 다시 상세 정보를 요청해 오는 풀 모델을 사용할 수도 있다.

풀 모델이 주체가 감시자를 몰라도 된다는 것에 중점을 두었다면, 푸시 모델에서 주체는 감시자의 요청이 무엇인지 알아야 한다. 푸시 모델을 사용하면 감시자 클래스의 재사용성이 떨어지게 된다. Subject 클래스는 Observer 클래스에 대한 어떤 가정을 하게 되는데, 이런 가정이 늘 맞는 것은 아니다. 그러나 풀 모델은 Observer 클래스가 Subject와 상관없이 무엇이 변했는지를 확인해야 한다는 점에서 비효율 적일 수 있다.

7. **자신이 관심 있는 변경이 무엇인지 명확하게 지정한다.** Subject 클래스에 자신이 관심 있는 이벤트에 대한 감시자를 등록하는 인터페이스를 정의함으로써 갱신의 과정을 좀더 효율화할 수 있다. 이렇게 명세한 관심 있는 이벤트가 발생할 때 주체는 등록된 감시자에게만 알려주면 된다. 이를 지원하기 위해서 Subject 객체는 양상이라는 개념을 사용한다. 

8. **복잡한 갱신의 의미 구조를 캡슐화 한다.** 주체와 감시자 간에 일어나는 관련성이 복잡한 것이라면, 이들 관련성을 관리하는 별도의 객체를 만들도록 한다. 이 객체를 ChangeManager 객체라고 하면, 이 객체의 목적은 감시자가 처리해야하는 주체의 변경 처리를 최소화하자는 것이다. 예를 들어, 연산의 수행으로 여러개의 서로 관련된 주체를 변경해야 한다고 가정해 보면, 모든 주체가 수정되고 나서, 이 주체의 감시자에게는 딱 한번만 통보되어야 한다. 즉, 감시자들에게 두번 이상 통보되는 것을 피하자는 것이다.

ChangeManager는 다음 3가지 책임을 진다.

- 주체와 감시자를 매핑하고 이를 유지하는 인터페이스를 정의해야 한다. 이로써 주체는 자신들의 감시자가 누구인지, 감시자는 자신들의 주체가 누구인지 관리할 필요가 없어진다.
- ChangeManager는  특별한 갱신 전략을 정의해야 한다.
- ChangeManager는 주체에게 요청이 있을 때 모든 독립적 감시자들을 수정해야 한다.

[image:A4A3A430-2429-4056-AAC0-4468B34C62AC-85545-0001CB5639A5B473/옵저버4.jpeg]

하나의 ChangeManager 클래스가 여러 객체 간의 상태 변화를 총괄한다는 점에서 ChangeManager 클래스는 일종의 중재자 패턴의 예다. 일반적으로 ChangeManager 클래스만 존재하므로 이 클래스 객체는 전역적으로 사용된다. 싱글톤 패턴으로 정의하는 것이 유용하다.

9. **Subject와 Observer 클래스를 합친다.** 다중 상속을 지원하지 않는 언어로 작성한 클래스 라이브러리들은 일반적으로 Subject와 Observer 클래스를 분리할 수 없으므로 하나의 클래스에 필요한 인터페이스를 합쳐야 한다. 이렇게 하면 다중 상속 없이도 주체와 감시자 역할을 하는 하나의 객체를 정의할 수 있게 된다.


### 관련 패턴

복잡한 갱신의 의미 구조를 캡슐화함으로써, ChangeManager 객체는 주체와 감시자 사이의 중재자 역할을 한다. ChangeManager 객체는 싱글톤을 써서 시스템에 하나만 존재하고 전역적으로 접근이 가능하도록 만들 수 있다.




