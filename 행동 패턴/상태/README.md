# #GoF디자인패턴/행동패턴/상태

## 상태 (State)

### 의도

객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 패턴으로 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것 처럼 보인다.


### 다른 이름

상태 표현 객체 (Object for State)


### 동기

네트워크 연결을 추상화한 TCPConnection 클래스를 생각해 보면, TCPConnection 객체는 여러 상태를 가질 수 있다. 간단히 예를 들어, 연결 성공 (Established), 대기 (Listening), 연결 종료 (Closed)의 상태를 갖는다. TCPConnection 객체는 다른 객체에서 동일한 요청을 받을 때, 자신의 현재 상태에 따라 다르게 반응한다. 예를 들어, Open  요청은 연결 상태가 “연결 종료” 또는 연결 성공 상태인지에 따라 처리하는 결과가 다르다. 이때는 상태 패턴을 쓴다. 상태 패턴을 쓰면 TCPConnection 클래스가 각 상태에서 어떻게 다르게 반응하는지 관리할 수 있다.

이 패턴에서 중요한 아이디어는 네트워크 연결에서 나타나는 모든 상태를 표현하는 TCPState 추상 클래스를 도입하는 것이다. TCPState 추상 클래스는 서로 다른 운영 상태를 표현할 다른 모든 서브클래스에 공통되는 인터페이스를 정의한다. TCPState의 서브클래스는 상태 종속적인 행동을 실제로 구현한다. 예를 들어, TCPEstablished 클래스는 연결 성공 상태에서 TCPClosed 클래스는 연결 종료 상태에서 국한된 행동을 구현한다.

[image:635631C4-5938-4B5F-A085-AB40047C219F-85545-0001E283523CF673/상태1.jpeg]

TCPConnection 클래스는 현재 TCP 연결 상태를 표현하는 객체를 내부에 유지한다. 이 상태 객체로 TCPConnection 클래스의 현재 상태를 파악할 수 있다. TCPConnection 클래스는 상태에 따라 달라지는 연산의 처리를 상태 객체 쪽으로 미룬다. 즉, TCPConnection 클래스는 TCPState 클래스의 서브클래스에서 만든 인스턴스를 사용해서 연결 상태 별로 특별한 연산을 처리하는 것이다.

연결 상태가 변할 때마다, TCPConnection 객체는 자신의 상태 객체를 TCPState의 서브클래스 중 하나의 인스턴스로 변경한다. 예를 들어, 상태가 “연결 성공”에서 “연결 종료”로 바뀌면, TCPConnection 클래스는 TCPEstablished 클래스의 인스턴스를 TCPClosed 클래스의 인스턴스로 변경한다.


### 활용성

다음 상황 가운데 하나에 속하면 상태 패턴을 사용할 수 있다.

- 객체의 행동이 상태에 따라 달라질 수 있고, 객체의 상태에 따라서 런타임에 행동이 바뀌어야 한다.
- 어떤 연산에 그 객체의 상태에 따라 달라지는 다중 분기 조건 처리가 너무 많이 들어 있을 때. 객체의 상태를 표현하기 위해 상태를 하나 이상의 나열형 상수로 정의해야 한다. 동일한 조건 문장들을 하나 이상의 연산에 중복 정의해야 할 때도 잦다. 이때, 객체의 상태를 별도의 객체로 정의하면, 다른 객체들과 상관없이 그 객체의 상태를 다양화 시킬 수 있다.


### 구조

[image:16FE34D7-0F7E-4B5C-B267-5C97F0FF9DA8-85545-0001E286E8B76C35/상태2.jpeg]


### 참여자

- **Context** (TCPConnection) : 사용자가 관심 있는 인터페이스를 정의한다. 객체의 현재 상태를 정의한 ConcreteState 서브클래스의 인스턴스를 유지, 관리한다.
- **State** (TCPState) : Context의 각 상태별로 필요한 행동을 캡슐화하여 인터페이스로 정의한다.
- **ConcreteState** 서브 클래스들 (TCPEstablished, TCPListen, TCPClosed) : 각 서브클래스들은 Context의 상태에 따라 처리되어야 할 실제 행동을 구현한다.


### 협력 방법

- 상태에 따라 다른 요청을 받으면 Context 클래스는 현재의 ConcreteState 객체로 전달한다. 이 ConcreteState 클래스의 객체는 State 클래스를 상속하는 서브클래스들 중 하나의 인스턴스이다.
- Context 클래스는 실제 연산을 처리할 State 객체에 자신을 매개변수로 전달한다. 이로서 State 객체는 Context 클래스에 정의된 정보에 접근할 수 있게 된다.
- Context 클래스는 사용자가 사용할 수 있는 기본 인터페이스를 제공한다. 사용자는 상태 객체를 Context 객체와 연결 시킨다. 즉, Context 클래스에 현재 상태를 정의하는 것이다. 이렇게 Context 객체를 만들고 나면 사용자는 더는 State 객체를 직접 다루지 않고 Context 객체에 요청을 보내기만 하면 된다.
- Context 클래스 또는 ConcreteState 서브클래스들은 자기 다음의 상태가 무엇이고, 어떤 환경에서 다음 상태로 가는지 결정할 수 있다. 즉, 상태는 상태 전이의 규칙이 있으므로 각각 한 상태에서 다른 상태로 전이하는 규칙을 알아야 한다.


### 결과

1. **상태에 따른 행동을 국소화하며, 서로 다른 상태에 대한 행동을 별도의 객체로 관리한다.** 임의의 한 상태에 관련된 모든 행동을 하나의 객체로 모을 수 있다. 한 상태에 종속적인 코드를 State 클래스의 서브 클래스에 모두 정의했기 때문에 새로운 상태와 새로운 전이 규칙이 발견되면 새로운 서브클래스만 정의하면 된다. (상태 패턴이 아니라면 if-else문이나 switch-case문으로 복잡하고 유지보수하기 힘들다)

하지만 이 패턴은 상태에 따른 행동을 여러 클래스에 나누어 정의하기 때문에 클래스의 개수가 많아질 수 있고, 또 단일 클래스보다 콤팩트한 것도 아니다. 그러나 상태가 많을 때는 상태가 흩어지는 편이 실제로 이익이다. (그렇지 않으면 큰 조건문이 필요함)

2. **상태 전이를 명확하게 만든다.** 어떤 객체가 자신의 현재 상태를 오직 내부 데이터 값으로만 정의하면, 상태 전이는 명확한 표현을 갖지 못한다. 이 상태 변수에 값을 할당하는 문장 정도밖에 없다. 각 상태별로 별도의 객체를 만들면 상태 전이를 명백하게 해주는 결과가 된다. 또한 State 객체는 Context 객체가 일관되지 않은 상태가 되는 것을 막아줄 수 있다. 이는 상태 전이가 Context 클래스의 관점과 상관없이 원자적이기 때문이다. 상태는 여러 개의 변수가 아니라 하나의 변수, 즉 Context의 State 객체 변수를 재바인딩함으로써 전이될 뿐이다.

3. **상태 객체는 공유될 수 있다.** 상태는 단지 타입으로만 표현되므로, State 객체는 인스턴스 변수 없이 여러 Context 클래스의 인스턴스로도 객체를 공유할 수 있다. 상태가 이런 식으로 공유될 때, 이 공유된 상태는 실질적으로 플라이웨이트 객체라고 해도 된다. (행동만 있는 플라이웨이트 객체)


### 구현

1. **누가 상태 전이를 정할 것인가?** 상태 패턴은 어떤 참여자가 상태 전이를 책임질지 명시하지 않는다. 만약 이런 기준이 고정되면, 이 기준을 Context 클래스 안에다가 구현할 수 있다. 하지만 State 클래스의 서브클래스들이 자신 다음에 나오는 상태가 무엇이고 상태 전이가 언제 될지를 정하도록 만드는 것이 일반적으로 더 유연하고 적절한 방법이다. 물론 이렇게 하려면 Context에 새로운 인터페이스를 추가하여 State 객체로 Context의 현재 상태를 정할 수 있도록 해야 한다.

상태 전이 처리 코드가 이렇게 분산되면 State의 새로운 서브클래스를 만드는 것이 더 쉬워진다. 그러나 이 방법에는 단점이 있다. State 서브클래스가 적어도 자신 다음에 나오는 다른 State 서브클래스를 알아야 한다는 것이다. 이것 때문에 서브클래스 사이의 구현 종속성이 생길 수 있다.

2. **테이블 기반의 대안.** 

3. **상태 객체의 생성과 소멸.** 구현할 때 가장 흔하게 생각하는 선택 사항은 상태 객체를 필요할 때만 생성하고 필요 없게 되면 없앨 것인가 아니면 필요하기 전에 미리 만들어 둔후 없애지 않고 계속 둘 것인가이다.

첫 번째 방법은 상태가 실행되기 전까지는 어떤 상태여야 하는지 모르거나 상황에 따라서 상태가 자주 바뀌지 않는 때라면 바람직하다. 이 방법은 사용하지 않는 객체는 생성하지 않는다는 원칙으로, State 객체가 많은 정보를 담고 있을 경우에는 유용하다. 두 번째 방법은 상태 변화가 수시로 일어날때 훨씬 좋은 방법이다. 필요할 때마다 다시 생성하고 없애고 하는 일을 반복할 필요가 없으므로, 처음 한번만 인스턴스를 생성하면 되고 또 없앨 필요도 없다. 그러나 이 방법의 단점은 Context 클래스가 언제나 모든 상태에 대한 참조자를 관리해야 한다는 부담이 생긴다.

4. **동적 상속을 이용하는 방법.** 어떤 특정 요청에 따라 행동을 바꾸려면 런타임에 객체가 클래스를 변경하는 것으로 해결되지 않을까 하는 생각이 들 수 있다. 그러나 이런 일은 대부분 객체지향 언어에서는 불가능하다. 


### 관련 패턴

상태 객체의 공유 시점과 공유 방법을 정의하는 데에 플라이웨이트 패턴을 사용한다. 상태 객체는 종종 하나만 존재할 때가 많은데, 이때는 싱글톤이다.



	