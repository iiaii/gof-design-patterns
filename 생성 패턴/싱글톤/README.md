# #GoF디자인패턴/생성패턴/싱글톤

[Effective Java Singleton](https://github.com/iiaii/EffectiveJava_Study/tree/master/2%EC%9E%A5%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EA%B3%BC%20%ED%8C%8C%EA%B4%B4/Item3%20%EC%8B%B1%EA%B8%80%ED%84%B4) (열거타입 싱글턴 사용을 권장)

#### 스레드 세이프한 싱글톤 방법
- static 멤버로 초기화(new Product())까지 한다 (전역에 선언)
- getInstance() 메서드에 synchronized 키워드를 추가한다
- 정적 클래스로 구현한다 (하지만 모든 메서드가 static 이어서 인터페이스를 구현할 수 없기 때문에 유연하지 못함 -> 테스트용 모의 객체 만드는 것 불가)
- enum


## 싱글톤 (Singleton)

### 의도

오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공한다.


### 동기

어떤 클래스는 정확히 하나의 인스턴스만을 갖도록 하는 것이 좋다. 시스템에 많은 프린터가 있다 하더라도, 프린터 스풀은 오직 하나여야 한다. 또한 파일 시스템도, 윈도우 관리자도 오직 하나여야 한다. 디지털 필터에 사용되는 A/D 변환기도 오로지 하나일 것이고, 한 회사에서는 하나의 회계 시스템만 운영될 것이다.

전역 변수를 이용해서 이 객체에 접근하도록 하면 여러개의 인스턴스를 만들 필요가 없다.

그러나 이보다 더 좋은 방법은 클래스 자신이 자기 유일한 인스턴스로 접근하는 방법을 자체적으로 관리하는 것이다. 이 클래스는 또 다른 인스턴스가 생성되지 않도록 할 수 있고(새로운 객체 생성에 대한 요청을 가로채는 방법을 쓴다), 클래스 자신이 그 인스턴스에 대한 접근 방법을 제공할 수 있다. -> 싱글톤 패턴


### 활용성

싱글톤 패턴은 다음 상황에서 사용한다

- 클래스의 인스턴스가 오직 하나여야 함을 보장하고, 잘 정의된 접근점으로 모든 사용자가 접근할 수 있도록 해야 할 때
- 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정 없이 확장된 서브클래스의 인스턴스를 사용할 수 있어야 할 때


### 구조

[image:3F5E06BA-F7E4-4762-B083-3BBB7EAA187F-85545-00011941D591F881/싱글톤1.jpeg]


### 참여자

- **Singletone** : Instance() 연산을 정의하여, 유일한 인스턴스로 접근할 수 있도록 한다. Instance() 연산은 클래스 연산이다(정적 멤버 메서드). 유일한 인스턴스를 생성(가져오는) 책임을 맡는다


### 협력 방법

- 사용자는 Singleton 클래스에 정의된 Instance() 연산을 통해서 유일하게 생성되는 단일체 인스턴스에 접근할 수 있다.


### 결과

싱글톤 패턴이 갖는 장점들은 다음과 같다.

1. **유일하게 존재하는 인스턴스로의 접근을 통제한다.** Singleton 클래스 자체가 인스턴스를 캡슐화하기 때문에, 이 클래스에서 사용자가 언제 어떻게 이 인스턴스에 접근할 수 있는지 제어할 수 있다.

2. **이름 공간을 좁힌다.** 싱글톤 패턴은 전역 변수보다 좋다. 전역 변수를 사용해서 이름 공간을 망치는 일을 없애주기 때문이다. 즉, 전역 변수를 정의하여 발생하는 디버깅의 어려움 등 문제를 없앤다.

3. **연산 및 표현의 정제를 허용한다.** Singleton 클래스는 상속될 수 있기 때문에, 이 상속된 서브클래스를 통해서 새로운 인스턴스를 만들 수 있다. 또한 이 패턴을 사용하면, 런타임에 필요한 클래스의 인스턴스를 써서 응용프로그램을 구성할 수도 있다.

4. **인스턴스의 개수를 변경하기가 자유롭다.** 마음이 바뀌어서 Singleton 클래스의 인스턴스가 하나 이상 존재하도록 변경하는 작업도 어렵지 않다. 응용프로그램이 사용하는 인스턴스가 다수여야 할 때도 같은 방법을 사용할 수 있다. 즉, Singleton 클래스의 인스턴스에 접근할 수 있는 허용 범위를 결정하는 연산만 변경하면 된다. (기존에는 하나의 인스턴스로만 접근을 허용했지만, 여러 개의 인스턴스를 생성해서 그 각각의 인스턴스로 접근할 수 있도록 연산의 구현을 바꾸면 되기 때문이다.

5. **클래스 연산을 사용하는 것보다 훨씬 유연한 방법이다.** 싱글톤 패턴과 동일한 기능을 발휘하는 방법이 클래스 연산을 사용하는 것이다 (static)


### 구현

싱글톤 패턴을 사용할 때의 고려 사항은 다음과 같다.

1. **인스턴스가 유일함을  보장한다.** 싱글톤 패턴은 클래스의 인스턴스가 오로지 하나임을 만족해야 한다. 가장 일반적인 방법은 인스턴스를 생성하는 연산을 클래스 연산으로 만드는 것이다. 이 연산은 유일한 인스턴스를 관리할 변수에 접근해서 이 변수에 유일한 인스턴스로 초기화하고, 이 변수를 되돌려 줌으로써 사용자가 유일한 인스턴스를 사용할 수 있도록 한다. 이 방법은 싱글톤 클래스의 인스턴스가 처음 사용되기 바로 직전에 그 인스턴스를 생성하고 초기화하도록 보장한다.

싱글톤을 전역 변수나 정적 객체로 정의하고 이를 자동 초기화하는 것으로는 충분하지 않다.

- 정적 객체의 유일한 인스턴스만 선언되리라는 보장을 할 수 없다. 즉, 정적 객체에서 인스턴스를 얻는 선언문이 프로그램의 다른 부분에 존재하더라도 이를 확인하고 방지할 방법이 없다.
- 정적 초기화 시점에 모든 싱글톤을 인스턴스화하기 위해 필요한 모든 정보가 없을 수도 있다. 싱글톤은 프로그램 실행 중간에 계산으로 자신의 값이 결정 될 수 도 있다. 그러나 정적으로 선언된 객체라면 그 내부에 정의된 변수의 값을 처음에만 정의할 수 있지, 나중에 다시 변경할 수는 없다. 이는 상수를 정의하는 것으로 이해하면 더 쉽다. (상수는 처음에 정의된 값만 허용하고 변경이 불가함)

또한 적역 객체나 정적 객체의 또 다른 문제는 모든 싱글톤의 사용 여부와 상관없이 일단 모두 생성된다는 것이다. 그러나 정적 메서드 기법을 이용하면 앞의 예에서처럼 실제 호출이 일어나는 시점에서 객체를 생성할 수 있다.

2. **Singleton 클래스를 서브클래싱한다.** 서브클래스를 만드는 것이 중요한게 아니라, 새로운 서브 클래스의 유일한 인스턴스를 만들어 사용자가 이를 사용할 수 있도록 하는 것이다. 핵심은 Singleton의 인스턴스를 참조하는 변수가 이들 서브클래스의 인스턴스로 초기화되러야 한다는 것이다. 가장 쉬운 방법은 Singleton 클래스의 Instance() 연산을 사용할 때 어떤 단일체를 사용할지 결정하는 것으로 슈퍼클래스의 싱글톤을 사용할지, 서브클래스의 싱글톤을 사용할지 결정한다. 

Singleton의 서브클래스를 선택하는 또 다른 방법은 Instance() 연산의 구현을 슈퍼클래스가 아닌 서브클래스에서 하는 것이다. 이것은 싱글톤의 구현 클래스를 연결 시점에 결정할 수 있게 해준다. (다른 구현을 포함한 목적 파일을 연결함으로써 가능하다)

연결 방법은 연결 시에 이미 단일체를 고정하기 때문에 런타임에 단일체 클래스를 선택하기가 힘들어진다. 서브클래스의 선택을 유연하게 하려면 조건 분기문을 사용해야 하는데, 이는 가능한 Singleton 클래스들에 대한 정보를 직접 코드에 작성하는 것이므로 좋지 않다. 양쪽 방법 모두, 모든 경우에 있어 유연한 방법은 아니다.

좀더 유연한 방법은 **싱글톤에 대한 레지스트리**를 사용하는 것이다. Instance() 연산에 가능한 Singleton 클래스 집합을 정의하는 대신에 Singleton 클래스는 이 단일체 인스턴스를 레지스트리에 이름을 갖는 인스턴스로 등록한다. 레지스트리는 문자열로 정의된 이름을 해당 단일체 인스턴스로 대응시켜 둔다. Instance() 연산에서 싱글톤이 필요할 때 레지스트리를 뒤져서 이름으로 해당 싱글톤을 찾아달라고 의뢰하면 레지스트리는 해당 싱글톤을 찾아 돌려준다. 이런 방식을 취하면 Instance() 연산이 모든 단일체 클래스와 인스턴스를 알 필요가 없다. 


### 관련 패턴

많은 패턴이 단일체 패턴으로 구현 가능하다. 추상 팩토리, 빌더, 원형 …
