# #GoF디자인패턴/생성패턴/빌더

[Effective Java 빌더 패턴 정리](https://github.com/iiaii/EffectiveJava_Study/tree/master/2%EC%9E%A5%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EA%B3%BC%20%ED%8C%8C%EA%B4%B4/Item2%20%EB%B9%8C%EB%8D%94) (GoF와는 조금 차이가 있음)

## 빌더

### 의도

복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공할 수 있도록 한다.


### 동기

RTF(Rich Text Format) 문서 판독기는 RTF 포맷에서 다른 텍스트 포맷으로 포맷을 바꿀 수 있어야 한다. 문서 판독기는 RTF 문서를 일반 ASCII 문서나 다른 텍스트 위젯으로 바꿀 수 있어야 하는데, 가능한 문서 형식들 간의 변환 가능성에 제한이 없으며, 판독기의 변경 없이도 새로운 형태의 변환이 추가될 수 있어야 한다.

이를 위해 RTF를 다른 문자식 표현으로 변형하는 일을 맡은 TextConverter 객체와 RTFReader 클래스를 함께 복합하는 방법이 필요하다. RTFReader는 RTF 문서를 분석할 때 TextConverter 클래스를 통해서 필요한 변환을 수행하도록 되어 있다. 즉, RTFReader는 RTF 토큰을 판독할 때 마다 TextConverter에 토큰을 변환하도록 요청한다. 그리고 TextConverter 객체는 데이터 변환을 수행하거나 어떤 특별한 형태로 토큰을 표현할 책임이 있다.

TextConverter의 서브클래스는 서로 다른 변환과 포맷을 처리할 수 있도록 갈라진다. 예를 들어, ASCIIConverter 클래스는 일반적인 아스키 텍스트의 변환만을 처리한다. TeXConverter 클래스는 TEX 형식의 문서를 생성하기 위해 필요한 모든 처리를 담당할 연산을 구현한다. TextWidgetConverter 클래스는 사용자가 볼 수 있고 텍스트를 편집할 수 있는 복잡한 사용자 인터페이스 객체(위젯)를 생성하는 서브클래스이다.

각 변환기(converter) 클래스들은 복잡한 객체를 생성하고 조립하는데 필요한 메커니즘을 Converter 클래스에 정의된 인터페이스의 각 연산에 구현한다. 이러한 변환기를 판독기와 분리시켜서, 판독기는 RTF 문서의 책임만 지게 하는 것이다.

각 변환기 클래스들이 **빌더** 패턴의 빌더이다. 그리고 판독기는 **디렉터**라고 한다. 예제에서 빌더 패턴은 문서 포맷을 해석하는 알고리즘(RTF문서 파싱)을 다른 형태로 어떻게 변환할 것인가를 결정하는 알고리즘과 분리해 낸다. 이 패턴을 쓰면 RTFReader의 파싱 알고리즘은 서로 다른 문서 형식으로 변형하는 용도로 재사용 될 수 있다. TextConverter 의 서브클래스에 맞추어 RTFReader를 설정하면 끝난다.

[image:098BF08E-2188-4961-81EF-0338FEBF78FD-85545-0000E1E5FDDCF929/빌더1.jpeg]


### 활용성

빌더 패턴은 다음의 경우에 사용한다

- 복합 객체의 생성 알고리즘이 이를 합성하는 요소 객체들이 무엇인지 이들의 조립 방법에 독립적일 때
- 합성할 객체들의 표현이 서로 다르더라도 생성 절차에서 이를 지원해야 할 때


### 구조

[image:4E0E81AB-773E-4E11-9E31-A269FFD94912-85545-0000E23DA0F9974D/빌더2.jpeg]


### 참여자

- Builder (TextConverter) : Product 객체의 일부 요소들을 생성하기 위한 추상 인터페이스를 정의한다.
- ConcreteBuilder (ASCIIConverter, TeXConveter, TextWidgetConverter) : Builder 클래스에 정의된 인터페이스를 구현하며, 제품의 부품들을 모아 빌더를 복합한다. 생성한 요소의 표현을 정의하고 관리한다. 또한 제품을 검색하는데 필요한 인터페이스 (GetASCIIText, GetTextWidget) 를 제공한다.
- Director (RTFReader) : Builder 인터페이스를 사용하는 객체를 합성한다.
- Product (ASCIIText, TeXText, TextWidget) : 생성할 복합 객체를 표현한다. ConcreteBuilder 는 Product 의 내부 표현을 구축하고 복합 객체가 어떻게 구성되는지에 관한 절차를 정의한다.


### 협력 방법

- 사용자는 Director 객체를 생성하고, 이렇게 생성한 객체를 자신이 원하는 Builder 객체로 합성해 나간다.
- 제품의 일부가 구축될 때마다 Director 는 Builder 에 통보한다.
- Builder 는 Director 의 요청을 처리하여 제품에 부품을 추가한다.
- 사용자는 Builder 에서 제품을 검색한다.

[image:5F0F2284-90D7-4B62-B699-8962AD7FBAD0-85545-0000E2EC58857F4E/빌더3.jpeg]


### 결과

빌더 패턴을 쓰면서 얻는 이익과 부담은 다음과 같다

1. **제품에 대한 내부 표현을 다양하게 변화할 수 있다.** Builder 객체는 디렉터를 제공하고 제품을 복합하기 위해 필요한 추상 인터페이스를 정의한다. 빌더를 사용하면 제품이 어떤 요소에서 복합되는지, 그리고 각 요소들의 표현 방법이 무엇인지 가릴 수 있게 된다.(캡슐화) 즉, 어떤 요소로 전체 제품을 복합하고 그 요소들이 어떤 타입들로 구현되는지 알고 있는 쪽은 빌더뿐이다. 제품을 복합할때는 빌더에 정의된 추상 인터페이스를 통해 사용자가 동작하기 때문에, 새로운 제품의 표현 방법이나 제품의 복합 방법이 바뀔 때 추상 인터페이스를 정의한 Builder 클래스에서 상속을 통해 새로운 서브 클래스를 정의하면 된다.

2. **생성과 표현에 필요한 코드를 분리한다.** 빌더 패턴을 사용하면, 복합 객체를 생성하고 복합 객체의 내부 표현 방법을 별도의 모듈로 정의할 수 있다. 사용자는 제품의 내부 구조를 정의한 클래스는 전혀 모른 채, 빌더와 상호작용을 통해서 필요한 복합 객체를 생성하게 된다. 왜냐하면, 이런 제품 구조에 대한 상세한 정의를 담은 클래스는 클래스에 정의된 어떤 연산의 매개변수로도 정의되지 않기 때문이다.
 각 ConcreteBuilder 는 특정 종류의 제품을 생성하고 조립하는 데 필요한 모든 코드를 포함한다. 코드는 한번만 작성된다. 이후에 Director 객체들이 이것을 재사용해서 똑같은 부품에서 여러 가지 Product 를 구축할 수 있다. RTF 의 예를 보면, RTF 이외의 형 포맷에 대한 판독기도 정의할 수 있는데, 이를 테면 SGMLReader 라는 것은 SGML 문서를 번역해서 ASCIIText, TeXText, TextWidget 을 생성할 때 동일한 TextConverter 를 재사용할 수 있다.

3. **복합 객체를 생성하는 절차를 좀더 세밀하게 나눌 수 있다.** 한번에 복합 객체를 생성하는 것처럼, 빌더 패턴은 디렉터의 통제 아래 하나씩 내부 구성요소들을 만들어 나간다. 디렉터가 빌더에서 만든 전체 복합 객체를 되돌려받을 때까지 제품 복합의 과정은 계속된다. 그렇기 때문에 Builder 클래스의 인터페이스에는 이 제품을 생성하는 과정 자체가 반영되어 있다. BuildPart() 메서드를 통해서 그 과정을 확인할 수 있다.


### 구현

추상 클래스인 Builder 클래스에 디렉터가 요청하는 각각의 요소들을 생성하는 연산들을 정의한다. 기본적으로 여기 정의된 연산은 아무것도 구현되지 않은 단순한 인터페이스일 뿐이다. 이 클래스를 상속하는 서브클래스 ConcreteBuilder 가 자신에게 필요한 요소를 생성하도록 부모 클래스의 연산을 재정의한다.

좀더 생각해야 할 구현 이슈를 정리하면 다음과 같다.

1. **조합과 구축에 필요한 인터페이스를 정의한다.** 빌더는 단계별로 제품들을 생성한다. 이를 위해서 모든 종류의 제품을 생성하는데 필요한 일반화된 연산들을 정의한다.

설계할 때 중요하게 생각해야 하는 것은 생성과 조합을 위한 모델 구축이다. 구축해 달라고 하는 요청이 오면, 요소를 제품에 단순하게 추가하는 식으로 모델을 구축하는 것으로 충분하다. RTF의 예를 보면, 빌더는 다음 토큰을 읽어 지금까지 변환한 텍스트 결과에 추가한다. 간혹 이미 구축된 제품의 부분에 대한 접근이 필요할 때가 있다. (미로의 예를 보면, 존재하는 방 사이에 문을 추가할 수 있도록 허용하는 연산이 MazeBuilder 인터페이스에 정의되어 있다) 파스 트리(parse tree)와 같은 트리 구조는 단순하게 요소를 추가하는 방법이 아닌, 자식 노드들을 모아서 부모 노드를 만드는 상향식으로 복합된다. 이때, 빌더는 디렉터에 자식 노드를 반환하고 다른 빌더에 이들 자식 노드를 반환해서 부모 노드들을 복합하게 한다. 이럴 때는 조립 모델이 상향식으로 구축되어야 한다.

2. **제품에 대한 추상클래스는 필요 없는가?** 일반적으로 제품은 상세화된 Builder 클래스의 서브클래스로 생성되는데, 제품마다 그 제품을 표현하는 방법이 다르고 이것에서 어떠한 공통점도 찾을 수 없기 때문에, 서로 다른 제품에 공통적인 기본 클래스를 준다고 해서 얻을게 별로 없다. (RTF 예에서 제품에 해당하는 ASCIIText와 TextWidget 객체는 공통된 인터페이스를 가질 수 없고 그럴 필요도 없다) 사용자는 디렉터를 만들 때 적당한 빌더를 제공하게 되고, 이 Builder의 서브클래스를 이용해서 적당한 제품을 만들고 다룰 수 있게 된다.

3. **Builder 에 있는 메서드에 대해서는 구현을 제공하지 않는 게 일반적이다.** 구현부를 비워두는 것이 바람직한데, 서브클래스에서 모든 가상 함수가 아니고 필요한 메서드만 재정의하기 위해서이다.


### 관련 패턴

복잡한 객체를 생성해야 할 때 추상 팩토리 패턴은 빌더 패턴과 비슷한 모습을 보인다. 근본적인 차이가 있다면 빌더 패턴은 복잡한 객체의 단계별 생성에 중점을 둔 반면, 추상 팩토리 패턴은 제품의 유사군들이 존재할 때 유연한 설계에 중점은 둔다. 빌더 패턴은 생성의 마지막 단계에서 생성한 제품을 반환하는 반면, 추상 팩토리 패턴에서는 만드는 즉시 제품을 반환한다. 추상 팩토리 패턴에서 만드는 제품은 꼭 모여야만 의미 있는 것이 아니라 하나만으로도 의미가 있기 때문이다.



