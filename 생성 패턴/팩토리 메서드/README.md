# #GoF디자인패턴/생성패턴/팩토리메서드

[Effective Java 정적 팩토리 메서드](https://github.com/iiaii/EffectiveJava_Study/tree/master/2%EC%9E%A5%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EA%B3%BC%20%ED%8C%8C%EA%B4%B4/Item1%20%ED%8C%A9%ED%86%A0%EB%A6%AC%EB%A9%94%EC%84%9C%EB%93%9C) (이름만 같고 다른 패턴)

## 팩토리 메서드

### 의도

객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다.


### 다른 이름

가상 생성자 (Virtual Constructor)


### 동기

프레임워크는 추상 클래스를 사용하여 객체 간의 관련성을 정의하고 유지할 수 있다. 또한 프레임워크는 이들 객체를 생성할 책임을 지니기도 한다. 프레임워크는 이들 추상 클래스 간의 상호작용을 책임져서 전체 시스템의 기본 동작 방식을 정의한다. 그리고 이들 추상 클래스를 상속하는 서브클래스에서 구체적인 행동을 정의함으로써 새로운 응용프로그램을 만든다. 

사용자에게 다양한 종류의 문서를 표현할 수 있는 응용프로그램 프레임워크가 있다고 간주하면, 일단 2개의 큰 추상화가 필요하다. 

- Application 클래스
- Document 클래스

이 클래스들은 모두 추상 클래스이고 사용자는 특정 응용프로그램에 종속적인 구현을 위해 새로운 서브 클래스를 정의할 수 있다. 그리기 관련 응용프로그램을 생성하려면 DrawingApplication 클래스와 DrawingDocument 클래스를 정의해야 한다. Application 클래스는 Document 객체를 관리하는 책임을 맡고 있으며, 필요에 따라 문서들을 생성하기도 한다. 예를 들어 Document 객체의 생성이나 관리는 사용자가 메뉴에서 Open이나 New를 선택할 때 이루어 지게 된다.

어떤 응용프로그램을 만드느냐에 따라 인스턴스로 만들어야 하는 Document의 서브 클래스가 달라지기 때문에, Application 클래스는 어떤 문서의 인스턴스를 생성해야 하는지 미리 예측할 수 없다. Application 클래스는 언제 문서의 인스턴스를 만들어야 하는지만 알고 있을 뿐, 어떤 종류의 문서를 생성해야 하는지는 알지 못한다. 프레임 워크는 클래스를 인스턴스로 만들어야 하지만, 추상 클래스 밖에 모르는 프레임워크는 클래스의 인스턴스화 작업을 수행할 수 없다. 왜냐하면 추상 클래스는 인스턴스를 가질 수 없기 때문이다. 

[image:A2B42E97-4939-409E-A785-54394D11037A-85545-0000F2B3A60CA243/팩토리메서드1.jpeg]

팩토리 메서드 패턴은 이런 문제에 대한 해법을 제시한다. 이 패턴은 Document의 서브클래스 중 어느 것을 생성해야 하는지에 대한 정보를 캡슐화하고, 그것을 프레임워크에서 떼어낸다.

Application 클래스의 서브클래스는 추상화된 CreateDocument() 연산을 재정의하여 적당한 Document 클래스의 서브클래스를 반환하도록 한다. Application 클래스의 서브클래스가 인스턴스화되면 응용프로그램에 따른 문서의 인스턴스가 된다. 이때, CreateDocument() 연산을 가리켜 **팩토리 메서드**라고 하는데, 객체를 “제조하는” 방법을 알기 때문이다.


### 활용성

팩토리 메서드는 다음과 같은 상황에 사용한다.

- 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때
- 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때
- 객체 생성의 책임을 몇개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때


### 구조

[image:8F49CCC4-D5CD-4F47-B577-5E2C02E3B4AA-85545-0000F31321EA90F3/팩토리메서드2.jpeg]


### 참여자

- **Product** (Document) : 팩토리 메서드가 생성하는 객체의 인터페이스를 정의한다.
- **ConcreteProduct** (MyDocument) : Product 클래스에 정의된 인터페이스를 실제로 구현한다.
- **Creator** (Application) : Product 타입의 객체를 반환하는 팩토리 메서드를 선언한다. Creator 클래스는 팩토리 메서드를 기본적으로 구현하는데, 이 구현에서는 ConcreteProduct 객체를 반환한다. 또한 Product 객체의 생성을 위해 팩토리 메서드를 호출한다.
- **ConcreteCreator** (MyApplication) : 팩토리 메서드를 재정의하여 ConcreteProduct의 인스턴스를 반환한다.
 

### 협력 방법

- Creator는 자신의 서브클래스를 통해 실제 필요한 팩토리 메서드를 정의하여 적절한 ConcreteProduct의 인스턴스를 반환할 수 있게 한다.


### 결과

팩토리 메서드 패턴은 응용프로그램에 국한된 클래스가 작성자의 코드에 종속되지 않도록 해준다. 응용프로그램은 Product 클래스에 정의된 인터페이스와 동작하도록 코드가 만들어지기 때문에, 사용자가 정의한 어떤 ConcreteProduct 클래스와도 동작할 수 있게 된다.

팩토리 메서드의 잠재적인 단점은 사용자가 ConcreteProduct 객체 하나만 만들려 할 때에도 Creator 클래스를 서브클래싱해야 할지 모른다는 점이다. 서브클래싱 기법은 사용자 Creator 클래스를 상속해서 서브클래스를 만들어야 할 때는 그럭저럭 훌륭한 방법이지만, 그렇지 않은 때라면 다른 방식으로 클래스의 진화 과정을 처리해야 한다.

다음은 팩토리 메서드 패턴을 쓰면서 얻는 또 다른 결과이다.

1. **서브클래스에 대한 훅 메서드를 제공한다.** 팩토리 메서드로 클래스 내부에서 객체를 생성하는 것이 객체를 직접 생성하는 것보다 훨씬 응용성이 높아진다. 팩토리 메서드 패턴에서는 객체별로 서로 다른 버전을 제공하는 훅 기능을 서브클래스에 정의한다.

Document의 예에서 Document 클래스는 CreateFileDialog라는 팩토리 메서드를 정의하여 기존의 문서를 열 때 기본 파일 다이얼로그를 생성할 수 있다. Document의 서브클래스는 이 팩토리 메서드를 재정의하여 응용프로그램에 적합한 또 다른 형태의 파일 다이얼로그를 정의할 수 있다. 이때, 팩토리 메서드는 추상 연산이 아니며, 적절한 기본 구현을 제공한다.

2. **병렬적인 클래스 계통을 연결하는 역할을 담당한다.** 예제에서 확인했듯이 Creator 클래스만이 팩토리 메서드를 호출하게 되어 있다. 하지만 꼭 이때만 그런것은 아니다. 팩토리 메서드는 병렬적인 클래스 계통이 만들어질 때 더욱 쓸모가 있다.

병렬적 클래스 계통은 클래스가 자신의 책임을 분리된 다른 클래스에 위임할 때 발생한다. 사용자와 대화식으로 처리되는 그래픽 객체를 생각해 보면, 그래픽 객체는 마우스를 통해 크기를 조정하고, 뒤집고, 이동시킬 수 있다. 이러한 상호작용을 구현하는 것은 항상 쉬운 일만은 아니다. 이런 구현의 어떤 시점에서는 조작의 상태를 저장하고, 조작에 필요한 정보를 저장, 수정하는 구현이 필요하게 된다. 이 상태는 조작 과정 중에서만 필요한 정보이지만, 그림 객체 자체에 저장될 필요는 없다. 서로 다른 그림은 서로 다르게 동작해야 한다. 즉, 선의 길이를 늘이는 것과 글자의 크기를 크게 하는 것은 다른 방식으로 구현해야 한다. 

[image:9F84FAF6-9BB3-4423-80BF-838911A75AD2-85545-0000F665BF70422D/팩토리메서드3.jpeg]

이들 제약 사항을 고려하면 사용자와의 상호작용을 구현하고 특정한 조작에 관련된 상태를 추적, 저장하는 별도의 Manipulator 객체를 사용하는 것이 바람직 하다. 각 그림은 서로 다른 Manipulator 클래스의 서브클래스를 사용하여 특정한 상호작용을 처리하게 하는 것이다. 필연적으로, Figure 클래스 계통이 커지는 것에 맞추어 이에 대한 Manipulator 클래스 계통도 계속 커지게 되는, 이른바 병행 클래스 계통이 되는 셈이다. 위의 그림과 같이 Document 클래스를 상속하는 LineFigure 클래스, TextFigure 클래스가 늘어날 때마다, Manipulator 클래스를 상속하는 LineManipulator, TextManipulator 클래스를 만든다.


### 구현

팩토리 메서드 패턴을 구현할 때는 다음 사항을 고려해야 한다.

1. **구현 방법이 크게 2가지 이다.** 

- Creator 클래스를 추상 클래스로 정의하고, 정의한 팩토리 메서드에 대한 구현은 제공하지 않는 경우
- Creator가 구체 클래스이고 팩토리 메서드에 대한 기본 구현을 제공하는 경우
(기본 구현을 일부 정의한 추상 클래스로 정의할 수도 있지만, 흔한 일은 아님)

추상 클래스로 정의할 때는 구현을 제공한 서브클래스를 반드시 정의해야 한다. 이때, 아직 예측할 수 없는 클래스들을 생성해야 하는 문제가 생긴다. 구체 클래스로 정의할 때는 Creator가 팩토리 메서드를 사용하여 유연성을 보장할 수 있다. 
`객체의 생성은 별도의 연산으로 분리하여, 이 연산을 서브클래스에서 재정의하게 한다` 이 규칙을 따르면 서브클래스 설계자는 부모 클래스가 인스턴스를 만드는 객체의 클래스를 변경할 수 있다.

2. **팩토리 메서드를 매개변수화한다.** 또 다른 구현 방식으로, 팩토리 메서드를 이용해서 여러 종류의 제품을 생성하는 방법도 있다. 팩토리 메서드가 매개변수를 받아서 어떤 종류의 제품을 생성할지 식별하게 만드는 것이다. 물론, 팩토리 메서드가 생성하는 모든 객체는 Product라는 인터페이스를 만족해야 한다. Document 예제를 가지고 본다면 Application 클래스는 서로 다른 종류의 문서를 지원해야 하는데, 이때 CreateDocument() 메서드에 생성할 문서 객체의 종류를 매개변수로 넘겨주면 된다.

Unidraw 그래픽 편집기 프레임워크의 예를 보면, 디스크에 저장된 객체를 재합성하기 위해 이런 접근법을 사용한다. 즉, Creator 클래스에 Create() 팩토리 메서드를 정의하고 클래스 식별자를 매개변수로 받도록 정의하였다. 이 클래스 식별자가 인스턴스화해야 할 클래스를 알려준다. Unidraw에서 그림 객체를 저장할 때 클래스 식별자를 먼저 기록하고 클래스 내부 멤버 변수를 저장한다.

디스크에 저장된 객체를 재생성할 때도 프레임워크는 클래스 식별자부터 먼저 읽어 Create() 메서드를 호출한다. 이때 읽은 식별자를 매개변수로 넘긴다. Create()는 해당하는 클래스를 생성하는데 필요한 생성자를 찾아서 객체를 생성하고, Create() 메서드는 다시 생성한 객체의 Read() 연산을 통해 저장된 멤버 변수를 읽도록 하며, 이를 이용해서 객체의 내부 변수를 초기화한다.

```java
public enum ProductId {
	YOURS, MINE, THEIRS
}

public Product MyCreator(ProductId id) {
	switch(id) {
		case ProductId.YOURS:
			return new YourProduct();
			break;
		case ProductId.MINE:
			return new MyProduct();
			break;
		case ProductId.THEIRS:
			return new TheirProduct();
			break;
	}

	return null;
// return Creator.Create(id); // 이외의것 부모 클래스에게 요청 
}
```

3. **언어마다 구현 방법이 조금 다를 수 있다.** 

4. **템플릿을 사용하여 서브클래싱을 피한다.** 팩토리 메서드를 쓰면 생길 수 잇는 잠재적인 문제점 중 하나는 그냥 Product 클래스 하나를 추가하려 할 때마다 서브클래싱을 해야한다는 점이다. 이로써 클래스 계통의 부피가 확장되는 문제가 생길 수 있다. 이를 해결하는 방법 중 하나는 Creator 클래스의 서브클래스가 되는 템플릿 클래스를 정의하고 이것이 Product 클래스로 매개변수화되도록 만드는 것이다. (템플릿 메서드 패턴)

5. **명명 규칙을 따르는 것도 매우 중요하다.** 팩토리 메서드를 쓴다는 사실을 명확하게 만들어 주는 명명 규칙을 따르는 좋은 습관을 들여야 한다. (매킨토시 응용프로그램 프레임워크는 팩토리 메서드의 이름을 DoMakeClass()로 선언한다. 여기서 Class는 Product  클래스)


### 관련 패턴

추상 팩토리 패턴은 이 팩토리 메서드를 이용해서 구현할 때가 많다. 추상 팩토리 패턴의 ‘동기’에서도 팩토리 메서드의 모습을 볼 수 있다.

팩토리 메서드는 템플릿 메서드 패턴에서도 사용될 때가 많다. 앞에서 본 문서 예제에서 NewDocument() 메서드가 바로 템플릿 메서드이다.

원형 패턴은 Creator 클래스의 상속이 필요하지는 않다. 그러나 Product 클래스에 정의된 초기화 연산은 필요하다. Creator 클래스는 객체의 초기화를 위해 초기화 연산을 사용하지만, 팩토리 메서드는 이런 연산이 필요하지 않다.





