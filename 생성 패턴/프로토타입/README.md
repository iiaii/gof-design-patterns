# #GoF디자인패턴/생성패턴/원형(프로토타입)

java -> Clone() 사용 (원형이되는 클래스에서 Cloneable 구현)
[Effective Java clone](https://github.com/iiaii/EffectiveJava_Study/tree/master/3%EC%9E%A5%20%EB%AA%A8%EB%93%A0%20%EA%B0%9D%EC%B2%B4%EC%9D%98%20%EA%B3%B5%ED%86%B5%20%EB%A9%94%EC%84%9C%EB%93%9C/Item13%20clone)

## 원형 (Prototype)

### 의도

원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성한다.


### 동기

그래픽 편집기 제작용으로 일반화된 프레임워크를 수정하여 음표와 쉼표, 보표를 표현하는 새로운 객체를 추가하면 음악 음계에 대한 편집기를 만들 수 있다. 이를 위해서 음악 객체를 악보에 추가하는 도구 팔레트 같은 것이 편집기 프레임워크에 있을 것이다. 사용자는 1/4 박자의 음조 도구를 선택하여 이를 악보에 추가할 수 있다. 또는 음표를 오선지 위아래로 이동시키는 이동 도구를 사용하여 가락을 조정할 수 있다.

프레임워크가 음표와 보표 같은 그래픽 요소들에 대한 추상화된 Graphic 클래스를 정의하고 팔레트 내 요소들 같이 도구를 정의하기 위한 추상화된 Tool 클래스를 제공한다고도 가정하면, 편집기 프레임 워크는 그래픽 객체의 인스턴스를 생성하여 문서에 추가하는 도구에 대한 GraphicTool이라는 서브클래스를 미리 정의한다.

그러나 이러한 GraphicTool 클래스는 프레임워크 설계자에게 문제를 일으킬 수 있다. 음표와 보표에 대한 클래스는 지금 개발할 응용프로그램에만 국한된 것이고, GraphicTool 클래스는 범용적인 프레임워크에 속해있는 것이다. 즉, 이러한 GraphicTool은 악보에 추가할 음악 클래스들의 인스턴스를 어떻게 생성해야 하는지 알지 못한다. 이런 이유로 우리 응용프로그램에서 필요한 음악 객체를 각각 생성하려면 GraphicTool을 상속받는 새로운 서브클래스를 만들어야 한다. 그러나 이렇게 되면 인스턴스화해야 하는 각 음악 객체 종류마다 여러 가지 다른 서브클래스를 만들어야 한다. 우리는 이미 객체 합성이 서브클래싱의 문제를 해결하는 또 다른 방법일 수 있다는 것을 안다. 문제는 프레임워크가 어떻게 복합을 이용하여, 프레임워크가 생성해야 하는 Graphic 클래스로 GraphicTool 클래스의 인스턴스를 매개변수화할 수 있는가 하는 것이다.

[image:E0C07B43-3D3C-43CC-8163-A5C52410622F-85545-000119368916FD49/프로토타입1.jpeg]


이를 해결할 수 있는 방법은 GraphicTool 클래스가 Graphic 서브클래스의 인스턴스를 복사(복제) 함으로써 새로운 Graphic 인스턴스를 만들도록 하는 것이다. 이렇게 복제된 인스턴스를 **원형**이라고 한다. GraphicTool은 자신이 복제해야 할 원형으로 매겨변수화되며 문서에 추가된다. 모든 Graphic 서브클래스가 Clone() 연산을 제공한다면 GraphicTool 클래스는 어떤 종류의 Graphic 클래스도 복제할 수 있게 된다.

그러므로 음악 편집기의 예에서 음악 객체를 생성하는 각 도구는 GraphicTool 클래스의 인스턴스이고, 이들은 서로 다른 원형으로 초기화된다. 각 GraphicTool 클래스의 인스턴스는 이 원형을 복제하여 음악 객체를 만들며, 이 복제본을 악보에 추가시킨다.

원형 패턴을 사용하면 심지어 클래스 수를 더 줄일 수 있다. 반음표, 온음표 등을 나타내는 클래스가 있긴 하지만 꼭 필요한 클래스로 보긴 힘들다. 이것보다 이들을 같은 클래스의 인스턴스로 생성하되, 각각을 서로 다른 비트맵 및 음길이 값을 이용해서 초기화하는 것이 더 좋은 방법이다. (즉, 클래스는 동일하게 하고, 안에 정의될 값이나 구조를 달리하는 것이 더 좋은 방법이다) 전체 음표를 만드는 도구는 보표로 GraphicTool이 되고, 이 GraphicTool의 클래스는 모든 음표에 초기화되는 MusicalNote가 될 것이다. 이로써 시스템에서 발생할 수 있는 클래스의 수를 많이 줄일 수 있다. 또한 새로운 종류의 음표를 쉽게 추가할 수 있다.


### 활용성

원형 패턴은 제품의 생성, 복합, 표현 방법에 독립적인 제품을 만들고자 할 때 쓴다. 그리고

- 인스턴스화할 클래스를 런타임에 지정할 때(이를테면, 동적 로딩)
- 제품 클래스 계통과 병렬적으로 만드는 팩토리 클래스를 피하고 싶을 때
- 클래스의 인스턴스들이 서로 다른 상태 조합 중에 어느 하나일 때 원형 패턴을 쓴다. 이들을 미리 원형으로 초기화해 두고, 나중에 이를 복제해서 사용하는 것이 매번 필요한 상태 조합의 값들을 수동적으로 초기화하는 것보다 더 편리할 수도 있다.


### 구조

[image:421B095D-C5E7-4DE5-BF20-14C3D352FC2F-85545-0001193818A9EE5C/프로토타입2.jpeg]



### 참여자

- **Prototype** (Graphic) : 자신을 복제하는데 필요한 인터페이스를 정의한다.
- **ConcreatePrototype** (Staff, WholeNote, HalfNote) : 자신을 복제하는 연산을 구현한다.
- **Client** (GraphicTool) : 원형에 자기 자신의 복제를 요청하여 새로운 객체를 생성한다.


### 협력 방법

- 사용자는 원형 클래스에 스스로를 복제하도록 요청한다.


### 결과

원형 패턴은 추상 팩토리 및 빌더와 비슷한 결과를 낳는다. 사용자 쪽에는 어떤 구체적인 제품이 있는지 알리지 않아도 되기 때문에 사용자 쪽에서 상대해야 하는 클래스의 수가 적다. 게다. 수정하지 않고도 응용프로그램에 따라 필요한 클래스들과 동작할 수 있게 된다.

원형 패턴의 추가적 특성은 다음과 같다.

1. **런타임에 새로운 제품을 추가하고 삭제할 수 있다.** 원형 패턴을 이용하면 사용자에게 원형으로 생성되는 인스턴스를 등록하는 것만으로도 시스템에 새로운 제품 클래스를 추가할 수 있게 된다. 런타임에 새로운 원형을 넣고 빼기가 쉽다는 점에서 다른 생성 패턴에 비해 유연성을 지니고 있다.

2. **값들을 다양화함으로써 새로운 객체를 명세한다.** 고도로 동적화된 시스템에서는 새로운 클래스를 생성할 필요 없이 객체 합성 (객체에 변수의 값을 지정하는 등) 으로 새로운 행동을 정의할 수 있다. 이 의미는 객체의 변수가 다른 클래스에 대한 참조자를 정의하고 있다면, 이 참조자가 합성한 새로운 클래스만 정의하고, 그 클래스의 인스턴스에 대한 참조자만을 넘겨주면, 새로운 행동이 정의되는 것처럼 보인다.마찬가지로 원형 패턴에서도 사용자와 동작할 원형에 해당하는 기존 클래스의 인스턴스를 만드러서 그 인스턴스를 등록하면, 사용자는 이 원형에 정의된 행동이 수행되어 마치 새로운 행동이 정의된 듯한 결과를 얻게 된다.

이런 식으로 설계된다면 추가 프로그램 없이도 새로운 클래스를 정의할 수 있다. 사실 원형을 복제하는 것을 클래스의 인스턴스를 만드는 것과 동일하다. 원형 패턴은 시스템에 필요한 객체를 생성하기 위해 정의할 클래스의 수를 대폭 줄여주는 효과가 있다. 음악 편집기 예제에서, 하나의 GraphicTool 클래스를 이용해서 다양한 종류의 음악 관련 객체를 무한정 만들 수 있다.

3. **구조를 다양화함으로써 새로운 객체를 명세할 수 있다.** 많은 응용프로그램은 구성요소와 부분 구성요소의 복합을 통해 객체를 구축한다. 예를 들어, 회로 설계를 위한 편집기는 세부 회로를 모아서 큰 회로를 만든다. 이런 응용프로그램에서는 편의를 위해 복잡한 사용자 정의 구조를 사용자가 인스턴스화하여 그 상황에 맞는 세부 회로를 계속 이용할 수 있도록 배려해 줄 때가 많다.

이때도 원형 패턴은 매우 좋은 해결책이 될 수 있다. 그냥 이 세부 회로를 원형으로 만들어, 이것을 현재 사용 가능한 회로 요소 관리 팔레트에 등록하기만 하면 된다. 그러고 나면 이 복합 회로 객체가 Clone() 연산을 구현함으로써 다른 구조를 갖는 회로의 기본 골격을 만든다.

4. **동적으로 클래스에 따라 응용프로그램을 설정할 수 있다.** 몇몇 런타임 환경에서는 동적으로 클래스들을 응용프로그램으로 등록할 수 있도록 해준다. 

동적으로 로드된 클래스의 인스턴스를 생성하고 싶은 응용프로그램은 정적으로 그 클래스의 생성자를 참조할 수 없다. 그 대신 런타임 환경이 그 클래스의 인스턴스를 자동으로 생성하고 원형 관리자에게 등록한다. 그러면 응용프로그램은 이 원형 관리자에게서 필요한 클래스의 인스턴스를 얻게된다. (원래 이 클래스는 프로그램과 연결되어 있지 않았던 것들임)


원형 패턴을 쓸 때 가장 신경써야 하는 부분은 원형의 서브클래스가 Clone() 연산을 구현해야 한다는 것이다. (까다로움) 예를 들어, 점찍어 놓은 클래스가 이미 만들어쪘다면 Clone() 연산을 추가하기 어렵다. 또한 복사를 지원하지 않거나 환형 참조가 없는 객체를 포함한다면 Clone() 연산의 구현은 어렵고 원형 패턴 적용이 힘들다.


### 구현

1. **원형 관리자를 사용한다.** 원형의 수가 아직 정해지지 않은 때라면 가능한 원형이 등록된 레지스트리를 관리해야 한다. 사용자는 원형 자체를 다루지는 않으며, 단지 레지스트리에서 원형을 검색하고 그것을 레지스트리에 저장할 뿐이다. 사용자는 원형을 복제하기 전에 레지스트리에 원형이 있는지 먼저 알아본다. 이런 레지스트리를 가리켜 **원형 관리자** 라고 한다.

원형 관리자는 어떤 키에 부합되는 원형을 저장하고, 찾아서 반환하며, 또 삭제하는 기능을 담당하는 저장소이다. 사용자는 런타임에 레지스트리를 변경하거나 검색할 수 있는데, 이것이 가능하기 때문에 코드를 쓰지 않고도 시스템에 있는 이런 관리 기능을 이용하거나 확장할 수 있다.

2. **Clone() 연산을 구현한.** 원형 패턴에서 가장 어려운 부분이 바로 Clone() 연산을 정확하게 구현하는 것이다. 특히 객체 구조가 환형 참조를 포함할 때라면 더욱더 어렵다.

복제 기능은 대부분 언어에서 웬만큼은 지원하지만, 얕은 복사(shallow copy)와 깊은 복사(deep copy)를 잘 구분하여 구현해야 한다.

3. **Clone을 초기화합니다.** 지금까지의 복제 방식에 만족을 느끼는 사용자가 있는 반면, 어떤 사용자는 내부 상태를 자신이 선택한 값으로 초기화하기를 바란다. 일반적으로는 이런 값은 Clone() 연산에 넘길 수 없다. 왜냐하면 원형 클래스마다 필요한 매개변수의 개수가 천차만별이기 때문이다. (어떤 원형은 여러개의 초기화 매개변수가 필요하고 어떤 원형은 전혀 필요가 없다. Clone() 연산에 매개변수를 정의하게 되면 복제 인터페이스의 일관성이 없어진다)


### 관련 패턴

원형 패턴과 추상 팩토리 패턴은 어떤 면에서는 경쟁적인 관계이다. (같이 사용되기도 함) 추상 팩토리 패턴은 원형 집합을 저장하다가 필요할 때 복제하여 제품 객체를 반환하도록 사용할 수도 있다. (복합체 패턴과 장식자 패턴을 많이 사용하는 설계에서 원형 패턴이 사용되기도 함)