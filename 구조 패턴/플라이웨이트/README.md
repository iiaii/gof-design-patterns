# #GoF디자인패턴/구조패턴/플라이웨이트
[구조 패턴 플라이웨이트 패턴(Flyweight Pattern) 이해 및 예제 :: 준비된 개발자](https://readystory.tistory.com/137)
[플라이웨이트 패턴(Flyweight Pattern) - 자바 디자인 패턴과 JDK예제 : 네이버 블로그](https://m.blog.naver.com/2feelus/220669069127)
(String Constant Pool, valueOf는 플라이웨이트패턴 예시임)

## 플라이웨이트 (Flyweight - 플라이급)

### 의도

공유를 통해 많은 수의 소립 객체들을 효과적으로 지원한다.


### 동기

객체 중심으로 설계함으로써 많은 효과를 거둘 수 있기는 하지만 하단을 실제로 구현하는 비용이 만만치 않은 응용프로그램이 있다.

예를 들어, 대부분은 문서 편집기는 텍스트 서식 설정과 편집의 기능이 모두 있으며, 이들은 어느 정도 모듈화되어 있다. 객체지향 문서 편집기의 테이블이나 그림과 같은 문서에서 처리할 요소들을 모두 객체로 표현한다. 그러나 개발 과정에서 문자 단위까지 객체로 설계하자는 생각까지 오면 조금 머뭇거리게 된다. 이렇게 작은 단위에서조차 객체를 이용하는 것이, 개발한 응용프로그램의 응용력을 높이는데도 말이다. 그렇다면 단일 문자난 다른 내장 요소들도 작도 및 서식화 방법에 따라 획일적으로 다룰 수 있을 것이다. 또한 새로운 문자 집합을 추가하더라도 다른 기능에 아무런 영향을 주지 않을  수 있다. 응용프로그램의 객체 구조를 문서의 물리적 구조와 흡사하게 흉내 낼 수 있다. (character objects, row objects, column object)

문자 하나를 객체로 관리하는 데는 비용이 많이 든다. 얼마되지 않은 분량의 문서라도 수천개의 문자 객체를 포함하고, 메모리와 실행 시간 낭비를 가져올 수 있다. 플라이웨이트 패턴은 이런 문제를 객체 공유를 통해 해결하는 방법을 보여준다.

플라이급 객체는 공유 가능한 객체로 여러 비슷한 상황에서 사용될 수 있다. 그러나 각각의 상황에서는 독립적인 객체로 동작한다. 이것은 공유될 수 없는 객체의 인스턴스와 구분이 안된다는 의미이다. 그러므로 플라이급 객체가 적용될 상황을 미리 가정하면서 소프트웨어를 개발할 수는 없다. (같은 것을 놓고 이런 상황에서는 이런 특징으로 정의하고 또 다른 상황에서는 다른 특징으로 정의할 수 없다는 것)
 플라이웨이트 패턴에서 중요한 개념은 본질적(intrinsic) 상태와 부가적(extrinsic) 상태의 구분이다. 본질적 상태는 플라이급 객체에 저장되어야 하며, 이것이 적용되는 상황과 상관없는 본질적 특성 정보들이 객체를 구성한다. 본질적이지 않은 부가적 상태는 플라이급 객체가 사용될 상황에 따라 달라질 수 있고, 그 상황에 종속적이다. 그러므로 공유될 수 없다. 사용자 객체는 이런 부가적 상태를 그것이 필요한 플라이급 객체에 전달해야 하는 책임을 갖는다.

플라이웨이트 패턴으로 모델링되는 개념이나 개체들은 객체로 표현하기에는 그 규모가 너무 작다. 문서 편집기에서 각 글자는 플라이급 객체로 생각해 볼 수 있다. 각 플라이급 객체는 문자 코드를 저장한다. 그러나 상황에 따라 달라질 문서의 위치와 인쇄 스타일 등은 텍스트 레이아웃 알고리즘과 서식 설정 방식으로 결정되어야 할 사항이다. 여기서 문자 코드는 본질적 상태에 대한 정보이고 위치와 스타일은 부가적인 상태에 해당한다.

논리적으로 글자를 객체로 대하겠다고 하면, 어떤 글자가 나타날 때마다 해당하는 객체가 존재해야 한다. 이것을 물리적으로 풀면, 공유된 하나의 플라이급 객체를 두고 이를 문서의 다른 문맥마다 나타나게 하는 것이다. 각각의 글자를 인스턴스로 갖기보다는 문서에 각 글자들이 나타날 때마다 플라이급 객체의 공유된 풀(Pool)에 존재하는 인스턴스에 대한 참조자를 갖도록 관리한다.

[image:41414B73-3DDD-4E14-9E23-8FC11E34E5E2-85545-00016C19CC08022A/플라이웨이트1.jpeg]

Glyph는 그래픽 객체에 대한 추상 클래스이며, 어떤 때는 플라이급 객체가 될 수도 있다. 부가적 상태에 따라 달라지는 연산은 해당 상태를 매개변수로 전달받는다. Draw()와 Intersect()는 Glyph가 어떤 상황에서 동작해야 하는지 먼저 알아야 하고, 이를 매개변수를 통해 전달 받는다. 매개변수로 현재의 Context가 전달되는 이유가 바로 이것이다.

[image:AAF46B13-7165-45D2-9FA1-08F5D52A4919-85545-00016C34B251E640/플라이웨이트2.png]

“a” 글자를 표현하는 플라이급 객체는 해당 글자 코드를 저장하지만, 위치나 폰트는 저장하지 않는다. 사용자는 이 상황에 따른 정보를 전달해 준다. Row 글리프는 스스로가 자신을 구성하는 요소들이 어느 줄에 나열되어야 하는지 알고 있다. 그러므로 자신이 화면에 나타날 때 자신을 구성하는 각 글자에 자신이 찍힐 위치를 전달해 주어야 한다. 

문자 객체의 가짓수는 문서 내의 문자 개수보다 훨씬 적기 때문에, 실제로 쓰는 객체의 총 개수는 일일이 문자 하나에 객체 하나로 구현할 때보다 엄청나게 적다. 모든 문자가 동일한 글꼴과 색깔로 찍혀잇는 문서는 문서의 길이와 상관없이 100개 정도의 문자 객체를 할당하게 된다. 그리고 어지간한 문서는 글꼴 - 색 조합이 많아야 10가지를 넘지 않으므로 실제로 이 개수가 현저하게 늘어나는 일은 없다. 그렇기 때문에 객체를 통한 추상화가 개개의 객체에 대해 실용성을 확보할 수 있게 된다.


### 활용성

플라이웨이트 패턴은 다음의 경우에 사용할 수 있다.

- 응용프로그로그램이 대량의 객체를 사용해야 할 때
- 객체의 수가 너무 많아져 저장 비용이 너무 높아질 때
- 대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때
- 부가적인 속성들을 제거한 후 객체들을 조사해 보니 객체의 많은 묶음이 비교적 적은 수의 공유된 객체로 대체될 수 있을 때. 현재 서로 다른 객체로 간주한 이유는 이들 부가적인 속성 때문이었지 본질이 달랐던 것은 아닐 때
- 응용프로그램이 객체의 정체성에 의존하지 않을 때. 플라이급 객체들은 공유될 수 있음을 의미하는데, 식별자가 있다는 것은 서로 다른 객체로 구별해야 한다는 의미이므로 플라이급 객체를 사용할 수 없다.


### 구조

[image:CFDE3654-02BB-4FB6-93BF-0DFF1B8F815E-85545-00016D9D023D20B1/플라이웨이트3.png]


### 참여자

- **Flyweight** (Glyph) : Flyweigth가 받아들일 수 있고, 부가적 상태에서 동작해야 하는 인터페이스를 선언한다.
- **ConcreteFlyWeight** (Character) : FlyWeight 인터페이스를 구현하고 내부적으로 갖고 있어야 하는 본질적 상태에 대한 저장소를 정의한다. ConcreteFlyweight 객체는 공유할 수 있는 것이어야 한다. 그러므로 관리하는 어떤 상태라도 본질적인 것이어야 한다.
- **UnsharedConcreteFlyweight** (Row, Column) : 모든 플라이급 서브클래스들이 공유될 필요는 없다. Flyweight 인터페이스는 공유를 가능하게 하지만, 그것을 강요해서는 안된다. UnsharedConcreteFlyweight 객체가 ConcreteFlyweight 객체를 자신의 자식으로 갖는 것은 흔한 일이다.
- **FlyweightFactory** : 플라이급 객체를 생성하고 관리하며, 플라이극 객체가 제대로 공유되도록 보장한다. 사용자가 플라이급 객체를 요청하면 FlyweightFactory는 이미 존재하는 인스턴스를 제공하거나 만약 존재하지 않으면 새로 생성한다.
- **Client** : 플라이급 객체에 대한 참조자를 관리하며 플라이급 객체의 부가적 상태를 저장한다.


### 협력 방법

- 플라이급 객체가 기능을 수행하는 데 필요한 상태가 본질적인 것인지 부가적인 것인지를 구분해야 한다. 본질적 상태는 ConcreteFlyweight에 저장해야 하고, 부가적인 상태는 사용자가 저장하거나, 연산되어야 하는 다른 상태로 관리해야 한다. 사용자는 연산을 호출할 때 자신에게만 필요한 부가적 상태를 플라이급 객체에 매개변수로 전달한다.
- 사용자는 ConcreteFlyweight의 인스턴스를 직접 만들 수 없다. 사용자는 ConcreteFlyweight 객체를 FlyweightFactory 객체에서 얻어야 한다. 이렇게 해야 플라이급 객체가 공유될 수 있다.


### 결과

플라이웨이트 패턴은 예전에 모두 본질적인 상태로 저장되어 있던 것을 부가적인 상태로 만들어, 부가적인 상태의 연산과 전송에 드는 런타임 비용을 새로 들여올 수 있다. 하지만 이런 비용은 플라이급 객체의 공유를 통해 저장소 절약이라는 반대급부를 가질 수도 있다. 저장소 절약은 여러 면에서 기능적이다.

- 공유해야 하는 인스턴스의 전체 수를 줄일 수 있다.
- 객체별 본질적 상태의 양을 줄일 수 있다.
- 부가적인 상태는 연산되거나 저장될 수 있다.

더 많은 Flyweight가 공유될수록 저장소는 절약된다. 또 공유할 상태가 많아질 수록 절약된다. 대부분의 본질적인 상태가 저장되고 부가적인 상태는 연산될 때라면 절약의 효과가 가장 크다. 이때는 본질적 상태를 저장하는 비용이 줄어드는 대신, 부가적 상태를 만들기 위한 연산의 시간을 투자해야 한다.

플라이웨이트 패턴은 컴포지트(복합체) 패턴과 조합하여 그래프와 같이 계층적 구조를 모델링하는데 사용한다. 이렇게 하면, 플라이급 단말 노드들은 자신의 부모에 대한 포인터를 저장할 수 없기 때문에, 부모 포인터를 부가적 상태의 일부로서 플라이급 객체에다가 매개변수로 전달해야 한다.


### 구현

1. **부가적 상태를 제외한다.** 패턴의 활용 여부는 얼마나 쉽게 공유할 객체에서 부가적인 상태를 식별하고 이를 분리하는가에 달려있다. 부가적인 상태 정보를 제거한다는 것은 객체의 저장소 공간을 그만큼 절약할 수 있다는 것이다. 이론적으로 이들 부가적 상태 정보는 별도의 객체 구조에서 계산될 수 있는 것으로 일반 상태를 저장할 때보다 더 작은 저장소가 필요하다.

문서 편집기의 예에서 인쇄 정보의 맵을 별도의 구조에다가 저장할 수 있다. 즉, 각 문자 객체마다 폰트나 스타일을 저장하지 않는다. 이 맵은 같은 인쇄 정보를 갖는 문자들을 추적한다. 맵은 문자가 찍힐 때마다 인쇄 정보를 받아둔다. 문서들은 몇몇의 폰트와 스타일을 사용하기 때문에, 각각의 글자마다 이 정보를 관리하기보다는 별도로 분리하여 저장하는 것이 훨씬 효과적이다.

2. **공유할 객체를 관리한다.** 객체는 공유할 수 있으므로, 사용자는 직접 인스턴스를 만들면 안된다. 객체는 공유할 수 있으므로, 사용자는 직접 인스턴스를 만들면 안된다. 그렇기 때문에 FlyweightFactory는 사용자가 특정한 플라이급 객체를 찾아내게 한다. FlyweightFactory 객체는 연관 저장소를 써서 사용자가 자신이 관심 있는 Flyweight를 찾아 볼수 있게 해준다. 예를 들어, FlyweightFactory는 문자 코드로 색인된 Flyweight의 테이블을 별도로 관리한다. 이것을 사용하여 코드에 해당하는 Flyweight가 있으면 이를 반환하고 없으면 새로 생성한다.

또한 공유 가능성은 플라이급 객체가 필요하지 않을 때 그것을 해제하는 참조 카운팅 혹은 가비지 컬렉션 능력에 따라 좌우된다. 하지만 Flyweight 수가 고정되었고, 또 작다면 어느 쪽도 필요하지 않다. (이때는 이를 메모리에서 삭제할 필요 없이 계속 두는 게 좋다)


### 관련 패턴

플라이웨이트는 컴포지트(복합체) 패턴과 함께 사용되는데, 공유되는 단말 노드를 갖는 방샹성 비순환 그래프 형태를 써서 논리적으로 계층 구조를 구현하는 것이 여기에 해당된다. 

상태 패턴 또는 전략 패턴을 플라이급 객체로 구현할 수 있다.



