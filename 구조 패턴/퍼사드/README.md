# #GoF디자인패턴/구조패턴/퍼사드
[09 퍼사드 패턴 (Facade Pattern)](https://lktprogrammer.tistory.com/42)
[퍼사드 패턴(Façade Pattern) :: 삐멜 소프트웨어 엔지니어](https://imasoftwareengineer.tistory.com/29)

## 퍼사드 (Facade - 정면, 실제와는 다른 표면)

### 의도 

한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴으로, 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의한다.


### 동기

시스템을 서브시스템으로 구조화하면 복잡성을 줄이는 데에 큰 도움이 된다. 공통적인 설계 목표는 서브시스템들 사이의 의사소통 및 종속성을 최소화하려는 것이다. 이런 목표를 달성하도록 도와주는 패턴이 퍼사드이다. 주어진 서브시스템의 일반적인 기능에 대해 단순화된 하나의 인터페이스를 제공하려는 것이다.

[image:162D145B-31AD-471B-9EB4-C9B37BB82A9D-85545-000164E2106D1079/퍼사드1.png]

한 예로, 응용프로그램이 컴파일러 시스템에 접근할 수 있는 어떤 프로그래밍 환경을 가정해보면 이 컴파일러 서브시스템은 Scanner, Parser, ProgramNode, BytecodeStream, ProgramNodeBuilder 등의 클래스를 포함한다. 이때 응용프로그램의 어느 특정 부분은 컴파일러에 정의된 이 클래스를 직접 사용해야 할지도 모른다. 그러나 응용프로그램들 대부분은 이런 구체적인 내용에 상관없이 파싱이나 코드 생성 단계를 단순히 이용하기만 한다. (컴파일만 되면 끝) 이들에게는 강력하지만 하위 수준에 있는 인터페이스가 오히려 일을 복잡하게 만들 뿐이다.

이런 클래스들로부터 사용자를 보호할 수 있는 더 상위 수준의 인터페이스를 제공하기 위해, 컴파일러 시스템은 컴파일러 클래스를 정의하고 컴파일러가 제공하는 기능성에 대한 인터페이스를 정의한다. (컴파일러 사용의 각 명령어만을 이용할 뿐, 실제 컴파일러가 어떤 클래스를 이용하여 컴파일 과정을 구현하는지 알 필요가 없다.


### 활용성

- 복잡한 서브시스템에 대한 단순한 인터페이스 제공이 필요할 때. 시스템 범위가 확장되면, 또한 구체적으로 설계되면 서브시스템은 계속 복잡해진다. 또한 패턴을 적용하면 확장성을 고려해 설계하기 때문에, 작은 클래스가 만들어지게 된다. 이런 과정은 서브시스템을 재사용 가능한 것으로 만들어주고, 재정의할 수 있는 단위가 되도록 해주기도 하지만, 실제 이런 상세한 재설계나 정제의 내용까지 파악할 필요가 없는 개발자들에게는 복잡해진 각각의 클래스들을 다 이해하면서 서브시스템을 사용하기란 어려운 일이다. 퍼사드 패턴은 서브시스템에 대한 단순하면서도 기본적인 인터페이스를 제공함으로써 대부분의 개발자들에게 적합한 클래스 형태를 제공한다.
- 추상 개념에 대한 구현 클래스와 사용자 사이에 너무 많은 종속성이 존재할 때. 퍼사드의 사용을 통해 사용자와 다른 서브시스템 간의 결합도를 줄일 수 있다. 즉, 서브시스템에 정의된 모든 인터페이스가 공개되면 빈번한 메서드 호출이 있을 수 있으나, 이런 호출은 단순한 형태로 통합하여 제공하고 나머지 부분은 내부적으로 처리함으로써 사용자와 서브시스템 사이의 호출 횟수는 실질적으로 감소하게 되는 효과를 갖는다.
- 서브시스템을 계층화시킬 때. 퍼사드 패턴을 사용하여 각 서브시스템의 계층에 대한 접근점을 제공한다. 서브시스템이 다른 서브시스템에 종속적이라 하더라도 각자가 제공하는 퍼사드를 통해서만 대화를 진행하게 함으로써 서브시스템 간의 종속성을 줄일 수 있다. 이로써 서브시스템 내부 설계의 변경이 독립적이고 자유롭게된다.


### 구조

[image:2EA88666-EE12-4AD7-9D1B-EFA526B63177-85545-0001658A6FFF9741/퍼사드2.jpeg]


### 참여자

- **퍼사드** (Compiler) : 단순하고 일관된 통합 인터페이스를 제공하며, 서브시스템을 구성하는 어떤 클래스가 어떤 요청을 처리해야 하는지 알고 있으며, 사용자의 요청을 해당 서브시스템 객체에 전달한다.
- **서브시스템 클래스들** (Scanner, Parser …) : 서브시스템의 기능을 구현하고, Facade 객체로 할당된 작업을 실제로 처리하지만 Facade에 대한 아무런 정보가 없다. 즉, 이들에 대한 어떤 참조자도 가지고 있지 않다.


### 협력 방법

- 사용자는 Facade에 정의된 인터페이스를 이용해서 서브시스템과 상호작용한다. 또 Facade는 해당 요청을 서브시스템을 구성하는 적당한 객체에게 전달한다. 서브시스템을 구성하는 객체가 실제의 요청 처리를 담당하지만 퍼사드는 서브시스템에게 메시지를 전달하기 위해 자신의 인터페이스에 동일한 작업을 정의해야 한다.
- 퍼사드를 사용하는 사용자는 서브시스템을 구성하는 객체로 직접 접근하지 않아도 된다.


### 결과

1. 서브시스템의 구성요소를 보호할 수 있다. 이로써 사용자가 다루어야할 객체의 수가 줄고 서브시스템을 쉽게 사용할 수 있다.

2. 서브시스템과 사용자 코드 간의 결합도를 더욱 약하게 만든다. 서브시스템에 정의된 요소들은 강하게 결합될수 있다. 서브시스템과 사용자 간의 결합이 약하면, 서브시스템 내의 요소를 다양화하는 작업을 원활하게 할 수 있다.
 대규모 소프트웨어 시스템에서는 컴파일 의존성을 줄이는 것도 매우 중요하다. 서브시스템 클래스가 바뀔 때 재 컴파일을 최소화함으로써 어떻게든 시간을 절약하고 싶을 것이다. 퍼사드를 사용해서 컴파일 의존성을 최소화하면 주요 서브시스템에서 작은 변경으로 들어가는 재컴파일을 제한할 수 있다. 퍼사드를 쓰면 다른 플랫폼으로 이식도 단순해진다. 하나의 서브시스템을 빌드하면 다른 모든 서브시스템까지 끌고 들어갈 때가 적어진다.

3. 응용프로그램 쪽에서 서브시스템 클래스를 사용하는 것을 완전히 막지는 않는다. 그러므로 Facade를 사용할지 서브시스템 클래스를 직접 사용할지 결정할 수 있다.


### 구현

1. **사용자와 서브시스템 간의 결합도 줄이기.** 사용자와 서브시스템 간의 의존성을 줄이는 방법은 Facade를 추상 클래스로 정의하고, 서브시스템을 나타내기 위해 이를 상속하는 구체 서브클래스를 정의하여 다른 구현을 정의하도록 하는 것이다. 그러면 사용자는 Facade만 사용하기 때문에, 어떤 서브시스템의 구현이 사용되고 있는지 알 필요가 없게 된다.
 서브클래싱을 하지 않으려면 다른 서브시스템 객체들을 조합하여 Facade를 구성할 수도 있다. Facade를 수정하기 위해서는 하나 이상의 서브시스템 객체를 대체하면 간단하게 끝난다.

2. **서브시스템 클래스 중 공개할 것과 감출 것.** 서브시스템은 클래스와 유사하다. 둘다 인터페이스를 가지며 무엇인가 감춘다. 클래스는 상태와 행동(연산)을, 서브시스템을 클래스를 캡슐화한다. 클래스의 인터페이스를 정의할 때 공개할지 말지를 고민하는 것처럼 서브시스템의 인터페이스도 공개할지 말지를 생각해 봐야 한다.
 서브시스템의 공개 인터페이스는 사용자가 직접 접근할 수 있는 클래스들이고, 비공개 인터페이스는 서브시스템 자체가 된다. Facade 클래스는 공개 인터페이스의 일부이다. 다른 서브시스템 클래스들도 모두 공개될 수 있다. 
 서브시스템 클래스를 비공개로 하는 것은 매우 유용한 일이기는 하지만, 많은 객체지향 언어가 이런 기능을 제공하지는 않는다.


### 관련 패턴

추상 팩토리 패턴은 서브시스템에 독립적인 방법으로 서브시스템 객체를 생성하는 인터페이스를 제공하기 위해 Facade와 함께 사용할 수 있다. 추상 팩토리는 Facade에 대한 대안으로서, 플랫폼에 종속적인 클래스를 감추는데 쓴다.

중재자 패턴도 기존에 존재하는 클래스의 기능성을 추상화한다는 점에서 퍼사드 패턴과 비슷하다. 중재자 패턴의 목적은 여러 객체들 사이의 협력 관계를 추상화하여 기능성의 집중화를 막자는 것이다. 중재자 패턴에 참여하는 객체는 서로를 직접 알지 못하고 단지 중재자를 통해서만 상호작용이 된다. 이에 비해 퍼사드는 서브시스템 인터페이스 자체를 추상화하여 사용을 용이하게 하려는 목적을 갖는다. 즉, 새로운 기능성을 추가할 수도 없고, 이런 새로운 추가 기능에 대해서는 알 수도 없다.

퍼사드 객체가 하나만 있어도 된다면, 싱글톤으로 구현한다.

