# #GoF디자인패턴/구조패턴/브릿지
[07 브릿지 패턴 (Bridge Pattern)](https://lktprogrammer.tistory.com/35)
[브릿지 패턴](https://www.crocus.co.kr/1537)

## 브릿지 (Bridge)

### 의도

구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 한다.


### 다른 이름

핸들 / 구현부 (Handle / Body)


### 동기

하나의 추상적 개념이 여라가지 구현으로 구체화될 수 있을 때, 대부분은 상속을 통해서 이 문제를 해결한다. 추상 클래스로 추상적 개념에 대한 인터페이스를 정의하고, 구체적인 서브클래스들에서 서로 다른 방식으로 이들 인터페이스를 구현한다. 그러나 이 방법만으로는 충분한 융통성을 얻을 수 없다. 상속은 구현과 추상적 개념을 영구적으로 종속시키기 때문에 추상적 개념과 구현을 분리해서 재사용하거나 수정, 확장하기가 쉽지 않다.

이식성 있는 Window를 추상적 개념으로 보고 이를 사용자 인터페이스 툴킷을 써서 구현하는 예를 생각해 보면, 이 Window 추상화는 X 윈도우 시스템에서 운영이 가능한 응용프로그램에서 사용되거나, IBM의 프레젠테이션 매니저에서 운영되는 응용프로그램에 적용될 수 있다. 상속을 이용하면 Window 추상 클래스를 정의하고 이를 상속받아서 서로 다른 플랫폼에서 운영될 PMWindow, XWindow 클래스를 구현하면 된다.

하지만 이 방법에는 2가지 문제가 있다.
---
1. 윈도우이기는 하지만, 다른 개념의 윈도우를 생성하거나 새로운 플랫폼에서 운영가능한 윈도우를 만들기 위해 Window 추상을 확장하기가 불편하다. 예를 들어 새로운 개념의 윈도우로 IconWindow를 Window의 서브클래스로 만들었다고 가정하면, 이 IconWindow가 만약 X 윈도우와 PM 윈도우 모두에서 동작 가능하려면 또 다시 새로운 클래스인 XIconWindow, PMWindow 서브클래스를 구현해야 한다. 이런 식으로 구현하면, 앞으로 만들 새로운 윈도우는 최상위 클래스인 Window를 상속받아 새로운 윈도우의 추가적 특성을 정의하여 구혀낳고, 이를 플랫폼별로 구현하기 위한 클래스를 자신의 서브 클래스로 늘려가게 된다. (자신과 동일한 레벨과의 호환성을 위해서 너무 복잡한 형태를 가지게 됨)

[image:4BD67D0A-BB94-4E36-A093-FD9743FDF998-85545-000141A542B3E925/브릿지1.png]

2. 사용자 코드가 플랫폼에 종속된다. 사용자가 윈도우를 만들 때마다 특정한 구현을 가진 구체 클래스를 인스턴스화해야 하는데, 이 특정한 구현이 바로 플랫폼에 종속적인 구현이다. 예를 들어, XWindow 객체를 생성하면 Window 추상이 XWindow 구현에 묶이게 된다. 따라서 사용자 코드 역시 XWindow 구현에 종속적으로 만들어진다. 이는 응용프로그램들이 서로 다른 플랫폼에 이식하기 어려움을 의미한다.

사용자는 구체적인 구현에 종속적일 필요 없이도 윈도우를 생성할 수 있어야 한다. 윈도우 구현만 응용프로그램이 실행되는 플랫폼에 의존적이면 된다. 따라서 사용자 코드는 특정한 플랫폼을 언급하지 않고도 윈도우를 인스턴스화 해야 한다.
----

이런 문제를 해결하기 위해 브릿지 패턴을 사용할 수 있다. 이는 추상적 개념에 해당하는 클래스 계통과 구현에 해당하는 클래스 계통을 분리함으로써 문제를 해결한다. 즉, 윈도우 인터페이스에 대한 계통 하나와 구현에 해당하는 계통 하나를 따로 구축한다. 윈도우 인터페이스의 최상위 클래스로 Window를 정의하고, 이를 구현하는 클래스의 최상위 클래스로 WindowImp를 정의한다. 물론 Window 클래스는 자신의 인터페이스를 실제로 구현하는 클래스가 어느 것인지에 대한 참조자(imp)를 정의해야 한다. Window 클래스에 정의된 연산은 WindowImp에 정의된 연산을 이용하여 기능이 완성되는 셈이다. WindowImp 클래스가 플랫폼에 종속적인 구현을 정의하므로 플랫폼별 서브클래스를 갖게 되고, Window 클래스는 윈도우에 대한 새로운 개념이 만들어질 때마다 그 개념을 추상화한 클래스로 Window의 서브클래스를 만들고 새로운 연산을 정의한다. 이러한 새로운 연산 역시 WindowImp 클래스를 상속받는 플랫폼에 종속적인 서브클래스가 정의한 연산에 의해 구현될 수 있다.

이때, Window 클래스와 WindowImp 클래스 간의 관련성을 가리켜 브릿지라고 정의한다.

[image:E962A78D-34B4-41A3-9FA9-B7A3376E5062-85545-0001422AB1FF013D/브릿지2.jpeg]


### 활용성

브릿지 패턴은 다음과 같은 경우에 사용한다.

- 추상적 개념과 이에 대한 구현 사이의 지속적인 종속 관계를 피하고 싶을 때 (런타임에 구현 방법을 선택하거나 구현 내용을 변경하고 싶을 때)
- 추상적 개념과 구현 모두가 독립적으로 서브클래싱을 통해 확장되어야 할 때 (브릿지 패턴은 개발자가 구현을 또 다른 추상적 개념과 연결할 수 있게 할 뿐 아니라, 각각을 독립적으로 확장 가능하게 한다)
- 추상적 개념에 대한 구현 내용을 변경하는 것이 다른 관련 프로그램에 아무런 영향을 주지 않아야 할 때 (추상적 개념에 해당하는 클래스를 사용하는 코드들은 구현 클래스가 변경되었다고 해서 다시 컴파일되지 않아야 한다)
- 속성의 정의나 구현 메서드가 별도의 클래스에 정의되고 사용자와 개발자가 보게 되는 클래스 소스 코드에는 구현 클래스에 대한 참조자만이 정의되어 있으므로 클래스의 구현과 속성에 대한 모든 표현 방식이 완전하게 은닉된다.
- 처음의 Motivation 다이어그램에서 본 것처럼 클래스 계통에서 클래스 수가 급증하는 것을 방지하고자 할 때. 이러한 클래스는 클래스 상속 계통에서 하나의 이유로 여러개 클래스가 갑자기 정의되어야 하는 상황이라면 객체를 두 부분으로 분리할 필요가 있음을 보여준다. 
- 여러 객체들에 걸쳐 구현을 공유하고자 하며 (참조 카운팅 등의 방법을 써서) 이런 사실을 사용자 쪽에 공개하고 싶지 않을 때. 간단한 예는 코플리엔의 String 인데, 이 클래스를 써서 인스턴스화된 객체들은 하나의 동일한 문자열 표현부를 공유할 수 있다.

### 구조

[image:4BDA14C2-BBA6-445F-B452-41D05A0D6E43-85545-0001435BFD1CCDC4/브릿지3.jpeg]


### 참여자

- **Abstraction** (Window) : 추상적 개념에 대한 인터페이스를 제공하고 객체 구현자에 대한 참조자를 관리한다.
- **RefinedAbstraction** (IconWindow) : 추상적 개념에 정의된 인터페이스를 확장한다.
- **Implementor** (WindowImp) : 구현 클래스에 대한 인터페이스를 제공한다. 실질적인 구현을 제공한 서브 클래스들에 공통적인 연산의 시그니처만을 정의한다. 이 인터페이스는 Abstraction 클래스에 정의된 인터페이스에 정확하게 대응할 필요가 없다. (두 인터페이스는 서로 다른 형태일 수 있다. 일반적으로 Implementor 인터페이스는 기본적인 구현 연산을 수행하고, Abstraction은 더 추상화된 서비스 관점의 인터페이스를 제공한다)
- **ConcreteImplementor** (XWindowImp, PMWindowImp) : Implementor 인터페이스를 구현하는 것으로 실제적인 구현 내용이 있다.


### 협력 방법

- Abstraction 클래스가 사용자 요청을 Implementor 객체에 전달한다.


### 결과

브릿지 패턴을 쓰면 다음 결과가 나온다.

1. **인터페이스와 구현 분리.** 구현이 인터페이스에 얽매이지 않게 된다. 추상적 개념에 대한 어떤 방식의 구현을 택할지가 런타임에 결정될 수 있다. 이는 런타임에 어떤 객체가 자신의 구현을 수시로 변경할 수 있음을 의미한다.

Abstraction과 Implementor의 분리는 컴파일 타임 의존성을 제거할 수 있다. 구현을 변경하더라도 추상적 개념에 대한 클래스를 다시 컴파일할 필요가 없고, 추상적 개념 클래스와 관련된 다른 코드 역시도 다시 컴파일할 필요가 없다.

그뿐만 아니라 더 잘 구조화된 시스템을 이끄는 계층화도 가능해진다. 이런 시스템의 상위 수준 영역에서는 Abstraction과 Implementor만 알면 된다.

2. **확장성 제고(향상).** Abstraction과 Implementor를 독립적으로 확장할 수 있다.

3. **구현 세부 사항을 사용자에게서 숨긴다.** 상세한 구현 내용을 사용자에게서 은닉할 수 있다.


### 구현

1. **Implementor 하나만 둔다.** 구현 방법이 오로지 하나일 때 Implementor를 추상 클래스로 정의하는 것은 불필요하다. 이것은 브릿지 패턴을 활용하는 효과가 퇴색한 예로서, 개념의 추상화와 이를 구현하는 구현 사이에 일대일 관계가 성립한다. 그럼에도 추상적 개념과 구현부를 분리하는 것은 여전히 의미가 있는데, 이는 사용자를 클래스 구현의 변경에서 독립시킬 수 있기 때문이다. (클래스의 구현이 변경되었다 하더라도 사용자를 다시 컴파일할 필요는 없고, 링크 과정만 재수행하면 된다)

2. **정확한 Implementor 객체를 생성한다.** Implementor 클래스가 여러개일 때 어떤 Implementor 클래스의 인스턴스를 언제, 어떻게, 몇 개나 생성해야 할까?

Abstraction 클래스가 모든 ConcreteImplementor를 알고 있다면, 이들 중 하나를 자신의 생성자 안에서 생성할 수 있다. 이 과정에서 필요하다면 생성자에 전달된 매개변수를 이용해서 어떤 것을 선택해야 하는지 결정할 것이다. 예를 들어, Collection 클래스가 여러개 구현되었다면, 어떤 구현을 사용할지는 지정하려는 집합체의 크기에 따라 달라진다. 소규모라면 연결 리스트를 이용하면 되고, 대규모라면 해시 테이블을 이용해야 할 것이다.

또 다른 방법은 초기에는 기본 구현을 선택한 후 필요에 따라서 다른 것을 선택하는 방법이다. 예를 들어, 구현의 크기가 점점 커지는 상황이 되어 어느 한계를 넘어가게 될 때 대량의 원소를 처리하기에 적합한 구현으로 변경하는 것도 방법일 수 있다.

결정을 다른 객체에게 위임하는 것도 가능하다. 예를 들어, Window/WindowImp의 예만 보면 팩토리 객체 개념을 도입할 수 있는데, 이때 팩토리 객체의 책임은 플랫폼에 따른 서로 다른 처리를 담당하게 하는 것이다. 팩토리는 어떤 WindowImp 객체가 지금 사용하는 플랫폼에 필요한지 결정하기 때문에 Window는 팩토리 객체에게 WindowImp를 생성해 달라고 요청하고, 팩토리는 현재 사용중인 플랫폼에 필요한 구현을 생성해 반환한다. 이 방법의 장점은 Abstraction 클래스는 어떤 Implementor 클래스와도 종속성을 갖지 않는다.

3. **Implementor를 공유한다.** 

4. **다중 상속을 이용한다.** 


### 관련 패턴

추상 팩토리 패턴을 이용해서 특정 브릿지를 생성하고 복합할 수 있도록 한다.

적응자 패턴은 서로 관련이 없는 클래스들이 함께 동작하게 만드는 쪽에 특화시켜 만든 패턴이다. 이 패턴은 대개 각 클래스의 설계가 끝난 후에 적용된다. 한편 브릿지 패턴은 설계 단계 초기에 투입되어 추상화 및 구현이 독립적으로 다양화되도록 만드는데 쓰인다.



