# #GoF디자인패턴/구조패턴/데코레이터

## 데코레이터 (Decorator - 장식자)

### 의도

객체에 동적으로 새로운 책임을 추가할 수 있게 한다. 기능을 추가하려면, 서브클래스를 생성하는 것보다 융통성 있는 방법을 제공한다.


### 다른 이름

래퍼 (Wrapper)


### 동기

전체 클래스에 새로운 기능을 추가할 필요는 없지만, 개별적인 객체에 새로운 책임을 추가할 필요가 있다. 예를 들어, GUI 툴킷에서 모든 사용자 인터페이스 요소에는 필요 없지만, 어떤 사용자 인터페이스 요소에만 스크롤링과 같은 행동이나 테두리(border)와 같은 속성을 추가할 수 있도록 해 줄 필요는 있다. 이 경우 하나의 객체에 속성이 추가됨으로써 또 다른 책임이 추가되어야 한다.

이렇게 새로운 서비스의 추가가 필요할 때 이를 해결하는 일반적인 방법은 상속을 이용하는 것이다. (이미 존재하는 클래스를 상속받고, 또 다른 클래스에서 테두리 속성을 상속받아 이 서브클래스의 인스턴스에 테두리가 있도록 함) 하지만 테두리의 선택이 정적이기 때문에 사용자는 구성요소를 언제, 그리고 어떻게 테두리로 장식해야 할지 제어할 수 없다.

더 나은 방법은 지금 필요한 테두리를 추가하는 다른 객체에다가 해당 구성요소를 둘러싸는 것이다. 이렇게 무엇인가를 감싸는 객체를 장식자(decorator)라고 한다. 장식자는 자신이 둘러싼 요소, 구성요소가 갖는 인터페이스를 자신도 동일하게 제공하므로, 장식자의 존재는 이를 사용하는 사용자에게 감춰진다. 즉, 장식자는 제공하므로, 장식자의 존재는 이를 사용하는 사용자에게 감춰진다. 즉, 장식자는 자신이 둘러싼 구성요소로 전달되는 요청을 중간에 가로채서 해당 구성요소에 전달해 준다. 따라서 이 전달 과정의 앞뒤에 다른 작업(테두리 그리기 등)을 추가할 수 있다. 여기에는 투명성이 존재하기 때문에 장식자의 중첩이 가능하며, 이를 통해 책임 추가를 무한정으로 할 수 있다.

예를 들어, 윈도우에 Text를 출력하는 서비스를 제공하는 TextView 클래스가 있다고 가정하고 TextView에는 스크롤 바가 없다고 하면, ScrollDecorator를 사용해서 TextView에 스크롤바를 추가할 수 있다. 또 두꺼운 테두리가 필요하면 BorderDecorator를 만들어서 TextView와 테두리 장식자를 복합하므로써 추가적 서비스 문제를 해결할 수 있다.

[image:8691BE29-5C57-4956-9571-F1DB8E0C6ADE-85545-00015EB4DD5FD9E4/데코레이터1.png]

BorderDecorator와 ScrollDecorator 객체를 이용해서 TextView를 복합한다.
ScrollDecorator와 BorderDecorator 클래스는 Decorator의 서브클래스들이며, 다른 시각 요소를 감싸는 시각 요소들을 위한 추상 클래스이다.

[image:7032C8EE-6BE5-4385-8755-9F930256CD07-85545-00015EF3A53A8ED7/데코레이터2.jpeg]

VisualComponent 클래스는 비주얼 객체를 위한 추상 클래스로, 그리기와 이벤트 처리에 필요한 인터페이스를 정의한다. Decorator 클래스는 단순하게 Draw()에 대한 요청을 자신이 갖는 요소에 전달할 뿐이다. 이 Decorator 클래스의 서브클래스들은 이 Draw() 연산을 확장하여 필요한 기능을 구현한다.

Decorator 클래스의 서브클래스는 필요한 서비스를 구현하기 위해서 특정 기능을 수행하는 메서드를 추가로 구현할 수 있다. 예를 들어, ScrollDecorator에 정의한 ScrollTo() 연산은 실제 스크롤 기능을 구현한다. 또 BorderDecorator에 정의된 DrawBorder()는 시각화 객체에 테두리를 만들어 주는 기능을 구현한 연산이다. BorderDecorator 클래스의 Draw() 연산 구현을 살펴보면, 기본적인 화면에 보이는 기능은 부모 클래스에서 제공받도록 부모 클래스에 정의된 Decorator의 Draw()를 호출하고, 추가적으로 자신에게 정의된 DrawBorder() 연산을 호출하여 테두리가 그려지도록 한다. 데코레이터 패턴의 중요한 특성은 장식자는 어떤 형태의 VisualComponent에 모두 적용할 수 있다는 것이다. 위의 예에서 TextView에만 추가적인 기능을 제공하는 것이 아니라, VisualComponent 클래스의 모든 서브클래스에 추가적인 기능을 제공할 수 있다.


### 활용성

데코레이터 패턴은 다음의 경우에 사용한다.

- 동적으로 또한 투명하게, 즉 다른 객체에 영향을 주지 않고 각각의 객체에 새로운 책임을 추가하기 위해 사용한다.
- 제거될 수 있는 책임에 대해 사용한다.
- 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용한다. 너무 많은 수의 독립된 확장이 가능할 때 모든 조함을 지원하기 위해 이를 상속으로 해결하려면 클래스 수가 폭발적으로 많아지게 된다. 아니면 클래스 정의가 숨겨지든가, 그렇지 않더라도 서브클래싱을 할 수 없게 된다.


### 구조 

[image:B5180CC3-92D1-497E-8CD0-61F36834C76B-85545-00015F5B83FF2510/데코레이터3.jpeg]


### 참여자

- **Component** (VisualComponent) : 동적으로 추가할 서비스를 가질 가능성이 있는 객체들에 대한 인터페이스
- **ConcreteComponent** (TextView) : 추가적인 서비스가 실제로 정의되어야 할 필요가 있는 객체
- **Decorator** : Component 객체에 대한 참조자를 관리하면서 Component에 정의된 인터페이스를 만족하도록 인터페이스를 정의
- **ConcreteDecorator** (BorderDecorator, ScrollDecorator) : Component에 새롭게 추가할 서비스를 실제로 구현하는 클래스


### 협력 방법

- Decorator는 자신의 Component 객체 쪽으로 요청을 전달한다. 요청 전달전 및 전달 후에 자신만의 추가 연산을 선택적으로 수행할 수도 있다.


### 결과

1. **단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있다.** 데코레이터 패턴은 객체에 새로운 행동을 추가할 수 있는 가장 효과적인 방법이다. 장식자를 사용하면 장식자를 객체와 연결하거나 분리하는 작업을 통해 새로운 책임을 추가하거나 삭제하는 일이 런타임에 가능해진다. 그러나 상속은 코드에서 정적으로 새로운 클래스를 추가해야만 추가적인 행동을 정의할 수 있다. 앞의 예를 상속으로 해결하는 경우 ScrollableTextView, BorderedTextView, BorderedScrollableTextView를 생성해야한다. (새로운 기능이 추가될 때 마다 계속 증가함) 
 그러나 데코레이터 패턴을 사용하면, 장식자의 조합을 통해서 새로운 책임도 조합할 수 있다. 이는 구조에 나타나는 바와 같이 Decorator 클래스와 Component 클래스 사이에 집합 관계가 정의되어 있어 Decorator는 Component 클래스의 인스턴스를 포함할 수 있는데, 이는 Component의 서브클래스인 ConcreteDecoratorA 클래스나 ConcreteDecoratorB 클래스의 인스턴스를 포함할수 있다. 이렇게 Decorator의 서브클래스를 아무런 코드의 수정없이 포함할 수 있으므로, Decorator 클래스의 서브 클래스 여러 개를 포함하면 여러 책임을 조합하는 결과가 된다.

2. **클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 피할 수 있다.** 데코레이터 패턴은 책임 추가 작업에서 “필요한 비용만 그때 지불하는” 방법을 제공한다. 지금 예상하지 못한 특성들을 한꺼번에 다 개발하기 위해 고민하고 노력하기보다는 발견하지 못하고 누락된 서비스들을 Decorator 객체를 통해 지속적으로 추가할 수 있다. 기능은 단순한 구성요소들의 조합으로 얻어질수도 있다. 그러므로 응용프로그램 개발 시 현재 사용되지 않은 기능까지 개발하기 위해 시간과 노력을 투자할 필요는 없다. 이는 나중에 실제 그 기능이 필요할 때 새로운 종류의 Decorator를 개발함으로써 가능하다.

3. **장식자와 해당 그 장식자의 구성요소가 동일한 것은 아니다.** 장식자는 사용자에게 일관된 인터페이스를 제공하는 껍데기이다. 그러므로 객체 식별자 관점에서 구성요소와 이를 둘러싼 Decorator 객체가 동일한 식별자를 가질 필요는 없다.

4. **장식자를 사용함으로써 작은 규모의 객체들이 많이 생긴다.** 데코레이터 패턴을 사용하는 설계에서는 작은 규모의 객체가 많아지는데, 이 객체들이 서로 다른 점은 상호작용하는 방법에 있지, 클래스가 다르거나 변수에 정의된 값이 다른 것은 아니다. 즉, 클래스들이 어떻게 조합하여 새로운 모습과 기능을 만들어내는가에 따라서 새로운 객체가 계속 만들어지기 때문이다. 이때 이 객체들을 잘 이해하고 있다면 시스템의 재정의가 쉽지만, 그렇지 않다면 객체들을 모두 이해하고 수정하는 과정이 복잡해진다. 


### 구현

1. **인터페이스 일치시키자.** Decorator 객체의 인터페이스는 반드시 자신을 둘러싼 구성요소의 인터페이스를 만족해야 한다. 따라서 ConcreteDecorator 클래스는 동일한 부모 클래스를 상속해야 한다.

2. **추상 클래스로 정의되는 Decorator 클래스 생략하자.** 간혹 추상 클래스인 Decorator 클래스를 정의할 필요가 없을 때도 있다. 이때는 Decorator 클래스에 정의할 책임이 한가지 밖에 존재하지 않는다. 이것은 새로운 클래스들을 설계할때 발생하기보다는 기존에 존재하는 클래스 계통을 사용해야 할 때 자주 일어난다. 이때 구성요소에게 요청을 전달하는 Decorator 클래스의 책임을 ConcreteDecorator 클래스와 합칠 수 있다.

3. **Component 클래스는 가벼운 무게를 유지하자.** 인터페이스를 만족하는지 확인하려면 구성요소와 Decorator 모두 동일한 부모 클래스인 Component 클래스를 상속받아야 한다. 이럴 때 Component 클래스를 가볍게 정의하는 것은 중요한 일이다. 가볍게 정의한다는 의미는 연산에 해당하는 인터페이스만을 정의하고 무언가 저장할 수 있는 변수는 정의하지 말라는 의미이다. 데이터 저장소를 정의하는 것은 서브클래스에서 할 일이다. 이렇게 하지 않으면 Component 클래스가 복잡해지고 Component를 상속받는 여러 Decorator들도 복잡하고 무거운 클래스가 되어 버린다. 또한 Component 클래스에 너무 많은 서비스를 정의하는 것 역시 서브클래스에는 부담이 된다. 각 서브 클래스는 자신에게 필요없는 연산까지도 적절한 구현을 해야하는 추가 부담이 생긴다.

4. **객체의 겉포장을 변경할 것인가, 속을 변경할 것인가.** 흔히 장식이란 행동을 변경할 수 있도록 객체에 외장을 입힌 것으로 알고 있다. 이렇게 겉만 바꾸는 것 뿐만아니라 내부도 변경 가능한데, 내부를 변경하는 대표적인 예가 전략패턴이다.

Component 클래스가 본질적으로 매우 복잡하고 무거운 특성을 갖는다면, 전략 패턴이 더 나은 해결 방안이다. 전략 패턴에서 구성요소는 자신이 받은 처리 요청을 분리된 Strategy 클래스에 전달한다. 전랙 패턴에서는 Strategy 객체의 대체를 통해서 구성요소의 기능성을 변경하거나 확장하는 방법을 제공한다.

예를 들어, Border 객체를 따로 두고, 객체마다 테두리를 처리하는 다양한 스타일을 제공할 때, Border 객체는 Strategy 객체가 되어 테두리를 그리는 전략을 담당한다. 이렇게 정의된 하나의 클래스를 기반으로 수많은 전략을 새로운 서브클래스로 정의하면 여러 개의 장식자를 중첩시키는 것과 동일한 효과를 거둘 수 있다.

데코레이터 패턴은 객체의 외관을 변경하는 것이므로 구성요소는 자신을 둘러싼 장식자에 대해서는 전혀 알 필요가 없다. (장식자는 구성요소에 대해 투명하다)

전략 패턴은 구성요소는 자신이 사용할 전략에 대한 참조자가 있고, 이것을 유지해야만 다양한 확장 기능을 얻을 수 있다. 

전략 기반의 방법을 사용하려면 새로운 확장이 가능하도록 구성요소를 변경해야 할 때가 있다. 한편 한 개의 전략은 자신만의 인터페이스가 있는 반면, 장식자의 인터페이스는 구성요소가 정의하는 인터페이스를 따른다. 
 테두리 음영을 처리로하는 전략을 예로 들면, DrawBorder(), GetWidth()와 같은 인터페이스만 정의하면 된다. 이 의미는 Component 클래스가 아무리 복잡해도 Strategy 클래스는 Component의 모든 연산을 다 정의할 필요 없이 추가된 부분만을 별도로 정의하면 된다.


### 관련 패턴

데코레이터 패턴은 적응자 패턴과 관련되어 있다. 장식자는 일종의 적응자로 볼 수 있다. 즉, 원래의 적응자는 인터페이스를 변경시켜주는 것이 었지만, 장식자는 객체의 책임, 행동을 변화시킨다.

복합체 패턴과도 관련된다. 장식자는 한 구성요소만을 갖는 복합체로 볼 수 있다. 그러나 이 목적은 객체의 합성이 아니라 객체에 새로운 행동을 추가하기 위한 것이다. 

전략 패턴과도 관련이 있는데, 장식자는 객체의 겉모양을 변경하고, 전략은 객체의 내부를 변화 시킨다. 객체를 변경하는 2가지 대안이다.




