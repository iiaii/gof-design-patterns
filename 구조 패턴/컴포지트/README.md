# #GoF디자인패턴/구조패턴/컴포지트
[Design Pattern 디자인 패턴 종류 - Heee’s Development Blog](https://gmlwjd9405.github.io/2018/07/06/design-pattern.html)

## 컴포지트 (Composite - 복합체)

### 의도

부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성한다. 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴이다.


### 동기

그래픽 편집기나 구조도 캡처 시스템 같은 그래픽 응용프로그램을 살펴보면, 사용자가 간단한 그림 구성요소들을 모아서 복잡한 다이어그램을 생성할 수 있게 한다. 사용자는 더 큰 그림 요소를 만들기 위해 구성요소들을 그룹으로 만들고, 이 그룹이 다시 더 큰 그룹을 형성하기도 한다. 이를 구현하기 위한 간단한 방법은 텍스트, 라인 등 간단한 기본 그림 요소에 대한 클래스들을 정의하고, 이를 포함한 컨테이너로 동작하는 클래스를 추가로 정의하는 것이다. 

그러나 이 접근법에는 문제가 있다. 각각의 그림에 해당하는 클래스들과 컨테이너 클래스들을 구분하기 위해 클래스의 속성으로 크기, 색, 위치 등의 기본 속성 이외 코드에 해당하는 속성을 정의해야 한다. 또한 이를 사용하는 응용프로그램 개발자는 코드 값을 기억하고 코드에 따라서 여러 분기를 처리해야 하는 어려움이 있다. (처리 대상이 컨테이너에 해당하는지, 개별 그림 요소에 해당하는지 판단하고 적절한 처리가 되도록 구현해야 한다)

[image:09A916B0-2D2A-4558-8BB4-43AE2BFC50E6-85545-00014989C1AD176B/컴포지트1.jpeg]

이를 위한 컴포지트 패턴의 가장 중요한 요소는 기본 클래스와 이들의 컨테이너를 모두 표현할 수 있는 하나의 추상화 클래스를 정의하는 것이다. 그래픽 응용프로그램 예에서 추상 클래스로 Graphic 클래스를 정의했다. Graphic 클래스에는 그림을 그리기 위한 기본 클래스의 연산인 Draw(), Add(), Remove(), GetChild() 등의 연산도 정의되어 있다. (복합 객체의 구성요소들을 다룰 연산들까지 정의하고 있음)

Graphic 클래스의 서브 클래스인 Line, Rectange, Text는 기본적인 그래픽 객체들로서 이들 클래스는 각각의 그림을 그릴 수 있는 Draw() 연산을 구현한다. 그러나 기본 그래픽들은 어떠한 요소 그래픽도 포함하고 있지 않으므로, 이들 서브클래스는 구성요소를 다루는데 필요한 연산을 구현하지는 않는다. Picture 클래스는 Graphic 객체들과 집합 관계가 성립되어, Graphic 객체들을 포함할 수 있는 복합 객체로 정의되어 있다. Picture 클래스도 Draw() 연산을 구현하며,  Add(), Remove(), GetChild() 등도 실제로 구현한다.

일반적인 복합 객체 구조의 재귀적 특성을 표현하면 다음과 같다.
[image:A9E078B3-C69B-41EE-9C13-B71833BA57A2-85545-00014A2FABD1B575/컴포지트2.jpeg]

MS 파워포인트에서 그룹 기능을 생각해보면 이해하기 쉽다. 그룹 기능은 이미 그려진 그림들을 모아서 하나의 그룹으로 만들게 되는데, 이때 Picture의 한 인스턴스가 생성되는 것이다. 가끔은 이미 그룹으로 만들어진 대상을 다른 요소들과 함께 좀더 큰 그룹을 만들기도 하는데, Picture 인스턴스가 또 다른 Picture 인스턴스를 포함하는 재귀적 포함 관계가 성립한다. 그러나 다루는 대상이 각각 그룹인지 그림인지를 구분하지 않은 채 Draw()를 요청할 수 있다.

Draw() 연산을 수행하는 객체가 그림 요소인 Line의 인스턴스이면 Line 클래스에 정의된 Draw()가 호출될 것이고, 그룹이었다면 Picture 클래스에 정의된 Draw()가 호출된다. 그러나 사용자 프로그램은 동일하게 Graphic 클래스에 정의된 연산으로만 접근하는 일관성을 갖게 된다.


### 활용성

복합체 패턴은 다음과 같은 경우에 사용한다.

- 부분 - 전체의 객체 계통을 표현하고 싶을 때
- 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때 (사용자는 복합 구조의 모든 객체를 똑같이 취급하게 된다)


### 구조

[image:919A3659-1509-4398-BD08-5A2029E3BE4B-85545-00014AA28F4BB8FA/컴포지트3.png]
-> 리스코프 치환 법칙을 고려해서 Leaf 에서 구현되지 않는 것은 Component에서 가져서는 안된다. (그림 수정이 필요할듯?)

### 참여자

- **Component** (Graphic) : 집합 관계에 정의될 모든 객체에 대한 인터페이스를 정의한다. 모든 클래스에 해당하는 인터페이스에 대해서는 공통의 행동을 구현한다. 전체 클래스에 속한 요소들을 관리하는 데 필요한 인터페이스를 정의한다. 순환 구조에서 요소들을 포함하는 전체 클래스로 접근하는 데 필요한 인터페이스를 정의하며 적절하다면 그 인터페이스를 구현한다.
- **Leaf** (Rectangle, Line, Text, 기타) : 가장 말단의 객체, 즉 자식 (여기서는 포함된 것을 일컫는다)이 없는 객체를 나타낸다. 객체 합성에 가장 기본이 되는 객체의 행동을 정의한다.
- **Composite** (Picture) : 자식이 있는 구성요소에 대한 행동을 정의한다. 자신이 복합하는 요소들을 저장하면서, Component 인터페이스에 정의된 자식 관련 연산을 구현한다.
- **Client** : Component 인터페이스를 통해 복합 구조 내의 객체들을 조작한다.


### 협력 방법

- 사용자는 복합 구조 내 객체 간의 상호작용을 위해 Component 클래스 인터페이스를 사용한다. 요청받은 대상이 Leaf 인스턴스이면 자신이 정의한 행동을 직접 수행하고, 대상이 Composite이면 자식 객체들에게 요청을 위임한다. 위임하기 전후에 다른 처리를 수행할 수도 있다.


### 결과

컴포지트(복합체) 패턴으로 발생하는 결과는 다음과 같다.

- 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의한다. 기본 객체는 더 복합적인 객체들에 속해있을 수 있다. 물론 복합 객체 역시 다른 것에 속해있는 것일 수 있다. 그러나 사용자 코드는 일반화된 상위 개념의 객체를 조작하는 방식으로 프로그래밍하면, 런타임 기본 객체와 복합 객체를 구분하지 않고 일관되게 프로그래밍할 수 있게 된다.
- 사용자의 코드가 단순해진다. 사용자 코드는 복합 구조이나 단일 객체와 동일하게 다루는 코드로 작성되기 때문이다. (사용자는 객체의 특성이 복합구조인지 단일구조인지 모르고 개발할 수 있다. 이런 구분이 필요치 않으므로 개발자의 코드에 “꼬리표-case-문장” 스타일의 함수를 쓸 필요가 없어지므로 코드가 단순해진다)
- 새로운 종류의 구성요소를 쉽게 추가할 수 있다. 새롭게 정의된 Composite나 Leaf의 서브클래스들은 기존에 존재하는 구조들과 독립적으로 동작이 가능하게 된다. 그러므로 새로운 요소가 추가되었다고 해서 사용자의 프로그램이 변경될 필요는 전혀 없다.
- 설계가 지나치게 범용성을 많이 가진다. 새로운 요소를 쉽게 추가할 때의 단점은 복합체의 구성요소에 제약을 가하기 힘들다는 것이다. 가끔 복합체가 오직 한개의 구성요소만 가졌으면 할 때가 있다. Composite 클래스만으로 타입 시스템을 통해 이런 제약을 가할 수 없다. 런타임 점검이 들어가야 한다.


### 구현

복합체 패턴을 구현할 때 고려할 사항을 정리하면 다음과 같다.

1. **포함 객체에 대한 명확한 참조자.** 자식 구성요소에서 부모를 가리키는 참조자를 관리하면 복합체 구조의 관리를 단순화할 수 있다. 부모에 대한 참조자는 구조를 거슬러 올라가거나 요소를 하나 삭제하는 과정을 단순화시킨다. 이 부모 객체에 대한 참조자는 나중에 정의할 책임 연쇄 패턴 구현에 도움이 된다.

부모 객체에 대한 참조자는 주로 Component 클래스에 두는데, Leaf 클래스와 Composite 클래스는 이 Component를 상속받고 있으므로, 실제로 두 클래스 모두 이 참조자를 관리하는 셈이다.

복합 구조가 중첩될 때, 복합 구조의 모든 자식들이 또 다시 부모가 되는데, 부모의 참조자가 있으면 이런 복합 구조에서는 반복적으로 자신들의 부모에 대한 참조가 가능하다. 한 부모의 자식들이 또 다른 자식들의 부모가 된다. 그러므로 자식은 자기 부모에 대한 참조자를 갖고, 또 부모는 자기 자식에게 참조된다. 복합 구조에서 추가나 삭제가 일어날 때만 구성요소의 부모를 변경하는데, 이로써 Comoposite 클래스의 Add() 및 Remove() 연산에서만 부모에 대한 참조자를 관리하면, 이를 상속하는 서브클래스에서는 이 코드를 상속 받아서 자동으로 부모에 대한 참조자를 관리할 수 있게 된다.

2. **구성요소 공유.** 구성요소를 공유하는 것은 매우 유용한 일이다. 메모리 저장 공간의 필요량을 줄일 수 있기 때문이다. 그러나 구성요소가 하나 이상의 부모를 갖는다면 구성요소를 공유하기는 어렵다.

가능한 해결책 중 한가지는 자식이 여러 부모를 갖게 하는 것이다. 그러나 메시지를 전달할 때 어떤 부모에게 의뢰해야 할지 애매할 수 있다. 부모들을 다 저장하지 않고도 어떻게 설계를 개선하는지에 대한 설명은 플라이웨이트 패턴에서 알 수 있다. 플라이웨이트 패턴은 자식들이 자신의 상태를 공개하여 부모에게 요청을 전달하지 않아도 될 때만 사용 가능하다.

3. **Component 인터페이스를 최대화.** 복합체 패턴의 주요 목표 중 하나는 사용자가 어떤 Leaf나 Composite 클래스가 존재하는지 모르도록 하는 것이다. 이런 목표를 달성하려면, Component 클래스는 Composite와 Leaf에 정의된 모든 공통의 연산을 다 정의하고 있어야 한다. Component 클래스는 이들 연산에 대한 기본 구현을 제공하고 Leaf와 Composite 클래스가 이를 재정의한다.

하지만 이런 목표가 종종 상속 구조의 중요한 원칙과 충돌할 때도 있다. 즉, Component 클래스에서는 서브클래스인 Leaf 클래스가 정의하지 않는 연산도 정의한다. Leaf 클래스에는 의미없고 Composite 클래스에만 의미 있는 연산도 Component 클래스에 정의해야 한다. 이런 연산들에 대해 Component 클래스는 기본 구현 사항으로 무엇을 제공할 수 있을까?

Composite에만 의미 있는 연산을 Component 클래스로 이동시켜서 모든 구성요소가 이 연산을 구현하는 것처럼 처리할 수도 있을 것이다. 즉, 자식들에 접근하는 인터페이스는 Composite 클래스에는 필수적이지만, Leaf 클래스에는 아무 의미가 없다. 그러나 Leaf 역시 Component 클래스의 서브클래스이지만 단지 자식들을 갖지 않는다고 볼수도 있다. 그러므로 Component 클래스의 자식을 처리하는 연산의 기본 구현 사항으로 아무것도 반환하지 않도록 기본 구현을 만들면 된다. 그리고 Leaf 클래스는 이 구현을 그대로 사용하고 Composite 클래스는 자식을 반환하도록 재정의하면 된다.

4. **자식을 관리하는 선언.** Composite 클래스가 Add()와 Remove() 연산을 통해서 자식들을 관리하기는 하지만, 복합체 패턴에서 매우 중요한 관심사는 Composite 클래스 계통 내의 어느 클래스에 이 연산을 선언할 것인가 결정하는 것이다. 이 연산들을 Component에 선언하고 Leaf 클래스에도 의미 있는 연산으로 만들던지, Composite 클래스와 이 서브클래스에만 의미 있는 연산으로 선언하던지이다.

이 결정은 안전성과 투명성 사이에 양자택일의 어려운 숙제를 낸다.

- 자식을 관리하는 인터페이스를 클래스 계통의 최상위 클래스에 정의하면 서브클래스 모두에게 동일한 인터페이스가 유지되어 이를 사용하는 사용자에게 인터페이스의 투명성을 부여할 수 있다. 반대로 사용자가 Leaf 클래스의 인스턴스에게 Add()나 Remove() 연산을 호출하는 의미 없는 행동을 하지 않도록 안전성 유지를 위한 비용을 지불해야 한다.
- Composite 클래스에만 자식을 관리하는 연산을 정의한다면, 이를 사용하는 사용자는 아예 Leaf 클래스의 인스턴스에 이런 연산을 요청하지 않을 것이므로 안전성은 보장 받는다. 그러나 Leaf 클래스와 Composite 클래스가 서로 다른 인터페이스를 갖게 되므로 사용자는 이를 동일한 대상으로 간주하고 사용할 수 없게 된다.

이 패턴에서 안전성보다는 투명성이 더 강조된다. 만약 안전성을 선택한다면, 처리하는 대상 객체가 어떤 클래스에서 만들어진 것인지에 대한 타입 정보를 잃어버릴 수도 있으며 Component를 Composite로 변환해야 할 수도 있다. 타입 안전성 없는 캐스트를 쓰지 않으려면 Component 클래스에 다음 연산을 선언하는 것이다. 

모든 구성요소를 동일한 방식으로 다루지 않는 문제도 있다. 어떤 연산을 호출하기 전에 이 연산을 처리할 수 있는 대상인지를 일일이 다 검사해야 한다. 이는 확장성이라는 측면에서 바람직하지 않다.

투명성을 보장하는 유일한 방법은 Component 클래스에 Add()와 Remove() 연산을 정의하는 것이다. 하지만 이방법은 새로운 문제를 야기하는데, Component Add() 를 구현할 때 반드시 실패할 때에 대한 언급이 필요하다. (Leaf 클래스에 무엇인가 추가하려는 시도는 오류 처리되어야 한다)

구성요소가 자식을 못 가진다든가 Remove()의 인자가 구성요소의 자식이 아니라면 대개 Add()와 Remove() 연산에서 기본적으로 실패하도록 만드는 것이 좋다. 즉, Add() 일 때는 해당 구성요소가 자식을 가질 수 있는지 확인하고, Remove()일 때는 해당 구성요소가 자식을 가질 수 있는지 확인하고, Remove()일 때는 인자가 구성요소의 자식인지를 확인하여 처리해야 한다.

또 다른 대안은 Remove() 연산의 의미를 수정하는 것이다. (부모에게서 자신을 삭제하는 개념)

5. **Component가 Component의 리스트를 구현할 수 있을까?** 자식들 집합을 Component 클래스의 인스턴스 변수로 관리하고 싶은 유혹에 빠질 수도 있다. Component 클래스에는 자식에 접근하고 관리하는 연산이 정의되어 있으니까 말이다. 그러나 최상위 클래스에 자식을 정의하는 것은 모든 Leaf 클래스의 인스턴스들도 이 집합을 관리하기 위한 메모리를 정의해야 하므로 바람직하지 않다. (Leaf 클래스의 인스턴스는 자식들을 전혀 가지고 있지 않음)

6. **자식 사이의 순서 정하기.** 자식간의 순서가 의미 있고 문제가 될 때는 자식에게 접근, 관리하는 인터페이스를 설계 시 자식들의 순서를 관리할 수 있도록 주의를 기울여야 한다. (반복자 패턴)

7. **성능 개선을 위한 캐싱.** 복합 구조 내부를 수시로 순회하고 탐색해야 한다면, Composite 클래스는 자식을 순회하는 정보를 미리 담고 있을 수도 있다. Composite 클래스가 탐색이나 최단 경로 순회의 실제 결과를 임시로 저장하는 것이다. 

8. **누가 구성요소를 삭제하는 책임을 질까?** 가비지 컬렉션이 없는 언어에서는 Composite 클래스가 보통 책임을 진다.

9. **구성요소를 저장하기 위해 가장 적당한 데이터 구조는?** (링크드 리스트, 배열, 트리, 해시 맵, 해석자 패턴 등)


### 관련 패턴

구성요소 - 부모 간의 연결은 책임 연쇄 패턴에서 많이 사용되는 예다.

장식자(데코레이터) 패턴은 자주 컴포지트 패턴과 함께 사용된다. 이 두 패턴이 함께 사용될 때는 둘 다 동일한 하나의 부모 클래스를 상속받게 된다. 따라서 장식자는 Add(), Remove(), GetChild()와 같은 연산을 통해서 Component의 인터페이스를 지원해야 한다.

플라이웨이트 패턴으로 구성요소의 공유 방법을 얻을 수 있다. 단, 공유되는 구성요소의 부모는 참조할 수 없다.

반복자 패턴을 이용하면, 구성요소를 순회하는 방법을 얻을 수 있다.

방문자 패턴을 이용하면 이 패턴을 사용하지 않을 때 Composite와 Leaf 클래스에 걸쳐 분산될 수 있는 행동을 국소화시킬 수 있다.


---
## Java 객체지향 디자인 패턴 - 컴포지트 패턴

컴포지트 패턴은 부분 - 전체 의 관계를 갖는 객체들을 정의할 때 유용하다. 그리고 클라이언트는 전체와 부분을 구분하지 않고 동일한 인터페이스를 사용할 수 있다.

- **Component** : 구체적인 부분, 즉 Leaf 클래스와 전체에 해당하는 Composite 클래스에 공통 인터페이스를 정의한다.
- **Leaf** : 구체적인 부분 클래스로 Composite 객체의 부품으로 설정한다.
- **Composite** : 전체 클래스로 복수 개의 Component를 갖도록 정의한다. 그러므로 복수 개의 Leaf, 심지어 복수 개의 Components 객체를 부분으로 가질 수 있다.


