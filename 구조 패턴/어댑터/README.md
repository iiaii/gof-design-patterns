# #GoF디자인패턴/구조패턴/어댑터
[Effective Java - 불필요한 객체 생성 회피](https://github.com/iiaii/EffectiveJava_Study/tree/master/2%EC%9E%A5%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EA%B3%BC%20%ED%8C%8C%EA%B4%B4/Item6%20%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%20%ED%9A%8C%ED%94%BC)
[Effective Java - 인터페이스](https://github.com/iiaii/EffectiveJava_Study/tree/master/4%EC%9E%A5%20%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/Item20%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4)
[Java(자바) 디자인패턴 - 어댑터(Adapter) 패턴 설명 및 예제소스](https://niceman.tistory.com/141)

## 어댑터 (Adapter)

### 의도

클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킨다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작 시킨다.


### 다른 이름

래퍼 (Wrapper)


### 동기

가끔은 재사용을 목표로 개발한 툴킷도 실제 재사용성을 발휘하지 못할 때가 발생한다. (즉, 응용프로그램이 요청하는 인터페이스와 툴킷에 정의된 인터페이스가 일치하지 않을 때가 있다)

예를 들어 그림 편집기는 사용자가 선, 다각형 텍스트와 같은 그래픽 요소를 이용하여 그림과 다이어그램을 만들 수 있도록 지원하는 응용프로그램이다. 그림판의 중요한 추상적 개념은 그래픽 객체들인데, 이들은 모양을 편집할 수 있는 특징을 가지며, 화면에 그려질 수 있는 행동을 정의한다. 이러한 공통의 그래픽 요소에 대한 인터페이스는 추상 클래스인 Shape에 정의한다. 그리고 그림 편집기는 각각의 그래픽 요소를 Shape의 서브클래스로 정의한다. (선을 위한 LineShape, 다각형을 위한 PolygonShape 등)

LineShape, PolygonShape 클래스와 같이 아주 기본적인 그래픽 요소들은 구현하기 쉽다. (이들의 그리기와 편집 기능은 제한적이기 때문) 그러나 TextShape 서브클래스는 다른 요소에 비해 구현이 그다지 용이하지 않다. 텍스트를 처리하려면 화면 수정과 버퍼 관리 등 복잡한 기능을 모두 구현해야 하기 때문이다. 한편 기존에 출시된 사용자 인터페이스 툴킷에서는 복잡한 TextView를 처리하는 클래스들을 이미 제공하고 있다. 그러므로 우리가 TextShape 클래스를 개발할 때는 TextView 클래스를 재사용하는 것이 바람직하다. 그러나 기존 툴킷 상품들은 지금 새롭게 개발한 Shape 클래스를 고려해서 개발된 것이 아니므로, 툴킷이 제공하는 TextView 클래스를 이번에 필요한 TextShape 클래스로 대체해 바로 사용할 수 있는 상황은 아니다.

그렇다면 TextView와 같이 이미 존재하기는 하지만 현재 이를 사용하고자 하는 클래스와는 아무런 연관 없이 개발될 클래스이거나, 서로 일치하지 않는 인터페이스를 갖는 클래스들을 잘 통합하여 하나의 응용프로그램을 개발해야 할 때, 이미 만든 클래스들을 잘 통합하여 운영할 수 있는 방법이 있을까? 다시 말해, 기존에 만든 TextView의 인터페이스를 변경해서 이를 사용하고자 하는 Shape의 인터페이스와 일치하게 만들 수 있을까?  만약 툴킷의 소스 코드를 갖고 있다면 가능하지만 소스가 없다면 TextView를 변경하는 것은 불가능하다. 그렇다고 이미 개발하여 사용된 툴킷 개발자가 하나의 응용프로그램을 동작시키기 위해 인터페이스를 변경해 달라는 요청을 들어줄수도 없다.

이미 개발된 클래스의 인터페이스를 수정할 수 없다면, Shape와 TextView 인터페이스에 둘다 맞도록 우리가 개발한 TextShape 클래스를 조정해야 한다. 이를 위해 취할수 있는 방법은 2가지 이다

- Shape의 인터페이스와 TextView의 구현을 모두 상속 받는다 (클래스 버전)
- TextView의 인스턴스를 TextShape에 포함시키고, TextView 인터페이스를 사용하여 TextShape를 구현한다 (객체 버전)

이들 두가지 방법은 적응자 패턴의 클래스 버전(첫 번째 방법) 및 객체 버전(두 번째 방법)에 해당한다. 이때 TextShape를 **적응자**라고 한다.

[image:54EAFD09-B771-4032-8868-AE10FC894183-85545-00012E96CF54DFDC/어댑터1.jpeg]

TextShape 클래스는 Shape 클래스를 상속받고 TextView 클래스의 인스턴스를 포함한다. TextShape 클래스를 상속받아 재정의한 BoundingBox() 연산의 구현을 살펴보면, 실제 구현을 제공할 TextView 클래스에 정의된 GetExtent() 메서드를 호출하도록 바꾸어 TextView에 전달하도록 되어 있다. TextShape 클래스는 TextView 클래스에 정의된 인터페이스를 바꾸어 Shape 클래스에 정의된 인터페이스와 부합되게 처리함으로써, 그림 편집기는 인터페이스가 불일치되는 문제가 있던 TextView 클래스를 TextShape 적응자를 통해 재사용할 수 있게 되었다.

가끔 적응자는 적은 대상 클래스가 제공하지 않는 기능을 제공하는 책임도 지니게 된다. 앞의 그림에서 사용자는 모든 Shape 객체를 다른 위치로 드래그할 수 있으나, TextView는 이 기능을 제공하지 않는다. TextShape는 상위 Shape 클래스가 가지고 있는 CreateManipulator() 연산에 드래그를 처리하는 행동을 추가로 정의하여 TextView에 빠진 이 기능을 제공한다. 즉, CreateManipulator() 연산을 Manipulator의 서브클래스인 TextManipulator의 인스턴스를 생성해 반환(return new TextMainpulator)하는 것이다.

Manipulator는 사용자 요청에 따라 Shape 인스턴스를 어떻게 움직여야 하는지(도형을 특정 위치로 드래그해서 옮기는 등)를 아는 추상 클래스이다. 그러므로 각 그래픽 요소별로 Manipulator 클래스를 상속받은 서브클래스의 정의가 필요하다. (TextManipulator는 TextShape에 대응되는 서브클래스이다) TextShape는 TextManipulator의 인터페이스를 반환하여 TextShape에는 없지만 Shape가 요구하는 기능을 추가한다.


### 활용성

적응자 패턴은 다음 상황에서 사용한다.

- 기존 클래스를 사용하고 싶은데 인터페이스가 맞지 않을 때
- 아직 예측하지 못한 클래스나 실제 관련되지 않는 클래스들이 기존 클래스를 재사용하고자 하지만, 이미 정의된 재사용 가능한 클래스가 지금 요청하는 인터페이스를 꼭 정의하고 있지 않을 때, 다시 말해, 이미 만든것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정하 수 없을 때
- [객체 적응자(object adapter)만 해당] 이미 존재하는 여러개의 서브클래스를 사용해야 하는데, 이 서브클래스들의 상속을 통해서 이들의 인터페이스를 다 개조한다는 것이 현실성이 없을 때. (객체 적응자를 써서 부모 클래스의 인터페이스를 변형하는 것이 더 바람직)


### 구조

클래스 적응자는 다중 상속을 활용해서 한 인터페이스를 다른 인터페이스로 적응 시킨다.

[image:E7236943-1852-4169-B5AF-1138AB6667A3-85545-00012FF3CDD59CF9/어댑터2.jpeg]

객체 적응자는 객체 합성을 사용한다

[image:51885C43-B69A-48DD-9DA8-AD4FA311F373-85545-00012FF941FAFBAD/어댑터3.jpeg]


### 참여자

- **Target** (Shape) : 사용자가 사용할 응용 분야에 종속적인 인터페이스를 정의하는 클래스로서, Shape를 예로 들 수 있다.
- **Client** (DrawingEditor) : Target 인터페이스를 만족하는 객체와 동작할 대상으로 DrawingEditor를 예로 들 수 있다.
- **Adaptee** (TextView) : 인터페이스의 적응이 필요한 기존 인터페이스를 정의하는 클래스로서 적응 대상자로서 TextView를 예로 들 수 있다.
- **Adapter** (TextShape) : Target 인터페이스에 Adaptee의 인터페이스를 적응시키는 클래스이다.


### 협력 방법

- 사용자는 적응자에 해당하는 클래스의 인스턴스에게 연산을 호출하고, 적응자는 해당 요청을 수행하기 위해 적응대상자의 연산을 호출한다.


### 결과

클래스 적응자와 객체 적응자는 각각 장단점이 있다. 

**클래스 적응자**는 
- Adapter 클래스는 Adaptee 클래스를 Target 클래스로 변형하는데, 이를 위해서 Adaptee 클래스를 상속받아야 하기 때문에, 하나의 클래스와 이 클래스의 모든 서브클래스들을 개조할 때라면 클래스 적응자 방식을 사용할 수 없다. 즉, Adapter는 명시적으로 Adaptee를 상속받고 있을 뿐 Adaptee의 서브클래스들을 상속받는 것은 아니므로, Adaptee의 서브클래스에 정의된 기능들을 사용할 수 없다.
- Adapter 클래스는 Adaptee 클래스를 상속하기 때문에 Adaptee에 정의된 행동을 재정의할 수도 있다.
- 한 개의 객체만 사용하며, Adaptee로 가기 위한 추가적인 포인터 간접화는 필요하지 않다.

**객체 적응자**는
- Adapter 클래스는 하나만 존재해도 수많은 Adaptee 클래스들과 동작할 수 있다. 왜냐하면 Adapter 객체가 포함하는 Adaptee에 대한 참조자는 Adaptee의 인스턴스를 관리할 수도 있고, Adaptee 클래스를 상속받는 다른 서브클래스들의 인스턴스도 관리할 수 있기 때문이다. 그러므로 하나의 Adapter 클래스로 모든 Adaptee 클래스와 이를 상속받는 서브클래스 모두를 이용할 수 있게 된다.
- Adaptee 클래스의 행동을 재정의하기가 매우 어렵다. 이것을 위해서는 Adaptee 클래스를 상속받아서 새로운 서브클래스를 만들고, Adapter 클래스는 Adaptee 클래스가 아닌 Adaptee 클래스의 해당 서브클래스를 참조하도록 해야한다.

Adapter 패턴을 사용하면서 고려해야할 추가적인 사항들

1. **Adapter 클래스가 실제 적응 작업을 위해 들어가는 품이 얼마나 되는가?** 이는 적응을 어떻게 시킬 것인가에 따라 달라진다. 즉, Adaptee 클래스에 정의된 내용을 사용자가 사용할 Target 인터페이스에 적응시키는 가장 단순한 예로 인터페이스 변환을 들 수 있다. 예를 들어, 연산의 이름을 변경하는 정도의 수준일 수도 있다. 즉, 작업량을 결정짓는 요인은 Target 인터페이스와 Adaptee 간에 얼마만큼의 유사성을 갖는가 하는 부분이다.

2. **대체 가능(Pluggable) 적응자.** 클래스의 재사용성을 높이려면, 누가 이 클래스를 사용할지에 대한 생각을 최소화해야 한다. 만약 인터페이스의 변경이 필요하다면 이 내용을 담은 클래스를 만들어 해결하면 되므로, 하나의 클래스를 설계할 때 모든 사용자가 원하는 표준화된 인터페이스를 정의해야 한다는 부담을 덜 수 있다. 즉, 내가 개발한 클래스를 사용할 모든 사용자에게 동일한 인터페이스를 제공해야 한다는 가정을 배제할 수 있다.

다른 인터페이스를 원하는 사용자가 있다면, 적응자 클래스를 만들면 된다. 또한 인터페이스의 개조를 통해 내가 만들 클래스는 기존에 존재하는 시스템과 함께 연동할 수 있게 된다. 기존 시스템은 내가 클래스를 만들기 전에 개발된 것이고, 또 나와 무관하게 개발되어 내가 만든 인터페이스를 기대하고 개발한 것이 아닐지라도, 개조를 통해서 나와 연동이 가능해 진다. (대체 가능 적응자라고도 함)

TreeDisplay 위젯을 생각해 봅시다. 이 기능은 트리구조를 그래픽적으로 보여주는 것이다. 이것이 어떤 특정 응용프로그램에서만 사용할 수 있는 특수 목적의 위젯이라고 생각해 보면, TreeDisplay 위젯이 디스플레이할 객체들은 특정 인터페이스를 갖도록 해야 하는데, 이 객체들은 Tree 추상 클래스를 상속해야만 한다. 그러나 TreeDisplay를 더 재사용성 있게 만들려고 한다면 이 요청은 터무니없는 것이다. 각각의 응용프로그램은 트리 구조를 표현하려는 자신만의 클래스를 정의할 것이다. 디렉터리 구조를 표현하려는 클래스가 다를 것이고 또 상속 구조를 표현하려는 클래스가 다르며 이들이 정의한 인터페이스가 다 다를 것이다. 이들 응용프로그램이 우리가 정의한 Tree 추상 클래스를 꼭 사용해야 한다고 강요해서는 안된다. 서로 다른 트리 구조는 서로 다른 인터페이스를 갖는다.

예를 들어, 디렉터리 계층을 보면 GetSubdirectories() 연산으로 하위 디렉터리에 접근한다. 반면에 클래스 상속 구조에서는 이에 대응되는 연산이 GetSubclasses()일 것이다. 만약, TreeDisplay 위젯의 재사용이 가능하려면 이렇게 서로 다른 인터페이스를 갖는 두 종류의 계층 구조라도 이들을 화면에 표시할 수 있어야 한다. 그러려면 TreeDisplay는 이렇게 다른 인터페이스를 자신이 아는 Tree 클래스의 인터페이스에 맞도록 적응시켜야 한다.

3. **양방향 적응자를 통한 투명성 제공.** 적응자의 잠재적인 문제는 적응자가 모든 사용자에게 투명하지 않다는 것이다. 적응된 객체는 더는 Adaptee 인터페이스를 만족하지 않는다. Target의 인터페이스를 만족하기 때문이다. 그렇게 되면 Target이 필요한 사용자에게는 적응된 클래스를 사용할 수 있겠지만, Adaptee 객체를 통해 Target을 사용해야 하는 사용자라면 적응된 객체를 사용할 수 없다. 양방향 적응이 되려면 이런 상황에서 모두 지원해야 한다. 즉, 서로 다른 두개의 사용자가 객체를 서로 다르게 바라봐야 할 때 필요한 기능이다. (양방향 적응자는 개조되는 두 클래스의 인터페이스를 모두  상속받아 정의하도록 하는 것이다)

[image:77D504FF-FDB2-4EBC-AA39-1C2D3D7E754A-85545-000137F76C1132FE/어댑터4.jpeg]


### 구현

1. Adapter 클래스는 Target 클래스에서 public으로 상속받고, Adaptee는 private로 상속받아야 한다. 즉, Target에 정의된 인터페이스는 Adapter에서도 public으로 공개되지만, Adaptee는 내부 구현에 필요한 것이므로, Adaptee가 사용자에 알려질 필요가 없다. 이렇게 되면 Adapter는 Target의 서브클래스이기는 하지만, Adaptee의 서브클래스는 아니다.

2. **대체 가능 적응자.** TreeDisplay 문제를 해결하는 적응자를 구현하는 방법은 3가지로 구분된다.

우선, Adaptee에 정의된 인터페이스들 중 적응이 필요한 연산의 최소 집합을 만든다. (이것은 3가지 방법 모두 공통) 이렇게 인터페이스를 축소하는 이유는 수십 개 연산을 갖는 인터페이스를 적응시키기보다는 한두개 인터페이스만을 적응시키는 것이 더 쉽기 때문이다. TreeDisplay를 위한 피적응자는 어떤 계층 구조도 될 수 있다. 최소 인터페이스가 정의된 Adapter는 아마도 두개의 연산을 가진다. 하나는 계층 구조를 어떻게 그래픽적으로 노드화하여 보여줄 것인가 정의하는 연산이고, 또 하나는 어떻게 이 노드의 자식 노드들을 검색할 것인가 정의하는 연산이다.

**(a) 추상 연산을 사용하는 방법.** 
범위가 제한된 Adaptee 인터페이스를 추상 연산으로 TreeDisplay 클래스에 정의한다. 이 클래스를 상속받는 서브클래스는 이 추상 연산에 대한 구현을 제공해야 하고, 계층 구조를 갖는 객체를 개조할 수 있다. 예를 들어, DirectoryTreeDisplay 서브클래스에서 이 연산을 구현할 때 디렉터리 구조에 접근할 수 있도록 개조하면 된다.

[image:C3535065-0941-457C-850D-EEC864D3CE77-85545-0001388308DC4EEB/어댑터5.jpeg]

BuildTree() 연산을 살펴보면, GetChildren()과 CreateGraphicNode() 연산을 이용하여 구현되고 있는데, 실제 수행 시에는 TreeDisplay를 상속하는 DirectoryTeeDisplay로 행동이 수행되어 FileSystemEntity로 접근하여 자식 노드를 얻으면 그래픽 노드 처리가 가능해진다. 다른 서브클래스를 갖게 되면 다른 개조 결과를 얻을 수 있게 된다.

**(b) 위임 객체를 사용하는 방법.**
TreeDisplay 클래스가 자신에게 요청된 메시지를 다른 위임 객체에게 전달하는 방법인데, TreeDisplay 클래스는 다른 위임 객체를 사용함으로써 다른 적응 전략을 구사할 수 있다. 
 예를들어 DirectoryBrowser 클래스가 TreeDisplay 클래스를 사용한다고 가정하면, DirectoryBrowser 클래스는 트리 구조를 계층적 디렉토리 구조로 개조하는 위임자 역할 수행한다. 

**(c) 매개변수화된 적응자를 사용하는 방법.**


### 관련 패턴

가교 패턴은 객체 적응자와 클래스 구조가 유사하지만 그 사용 목적이 다르다. 가교 패턴은 구현과 이 구현이 만족할 추상 개념을 분리해 서로에게 영향을 주지 않고 각각 확장할 수 있도록 하려는 것이고, 적응자 패턴은 존재하는 객체의 인터페이스를 변경하려는 것이다.

장식자 패턴은 다른 인터페이스의 변경 없이도 객체에 새로운 행동을 추가할 수 있도록 한다. 이것이 적응자보다는 응용프로그램을 위해 훨씬 좋은 방법이고 순수한 적응자로는 불가능한 재귀적 합성을 가능하게 한다.

프록시 패턴은 다른 객체에 대한 대표자 또는 대리인 역할을 수행하지만 인터페이스를 변경하는 책임은 없다.







